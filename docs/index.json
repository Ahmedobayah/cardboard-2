[
  {
    "description": "Cardboard client generator",
    "tags": [
      {
        "title": "param",
        "description": "a configuration object",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "config"
      },
      {
        "title": "param",
        "description": "the name of a DynamoDB table to connect to",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "config.table"
      },
      {
        "title": "param",
        "description": "the AWS region containing the DynamoDB table",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "config.region"
      },
      {
        "title": "param",
        "description": "the name of an S3 bucket to use",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "config.bucket"
      },
      {
        "title": "param",
        "description": "the name of a folder within the indicated S3 bucket",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "config.prefix"
      },
      {
        "title": "param",
        "description": "a pre-configured [dyno client](https://github.com/mapbox/dyno) for connecting to DynamoDB",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "dyno"
          }
        },
        "name": "config.dyno"
      },
      {
        "title": "param",
        "description": "a pre-configured [S3 client](http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html)",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "s3"
          }
        },
        "name": "config.s3"
      },
      {
        "title": "returns",
        "description": "a cardboard client",
        "type": {
          "type": "NameExpression",
          "name": "cardboard"
        }
      },
      {
        "title": "example",
        "description": "var cardboard = require('cardboard')({\n  table: 'my-cardboard-table',\n  region: 'us-east-1',\n  bucket: 'my-cardboard-bucket',\n  prefix: 'my-cardboard-prefix'\n});"
      },
      {
        "title": "example",
        "description": "var cardboard = require('cardboard')({\n  dyno: require('dyno')(dynoConfig),\n  bucket: 'my-cardboard-bucket',\n  prefix: 'my-cardboard-prefix'\n});"
      },
      {
        "title": "name",
        "name": "Cardboard"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 39,
          "column": 0
        },
        "end": {
          "line": 599,
          "column": 2
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/index.js",
      "code": "var _ = require('lodash');\nvar Metadata = require('./lib/metadata');\nvar uniq = require('uniq');\nvar queue = require('queue-async');\nvar Dyno = require('dyno');\nvar AWS = require('aws-sdk');\nvar extent = require('geojson-extent');\nvar cuid = require('cuid');\nvar tilebelt = require('tilebelt');\nvar geobuf = require('geobuf');\nvar stream = require('stream');\n\nvar MAX_GEOMETRY_SIZE = 1024 * 10;  // 10KB\n\n/**\n * Cardboard client generator\n * @param {object} config - a configuration object\n * @param {string} config.table - the name of a DynamoDB table to connect to\n * @param {string} config.region - the AWS region containing the DynamoDB table\n * @param {string} config.bucket - the name of an S3 bucket to use\n * @param {string} config.prefix - the name of a folder within the indicated S3 bucket\n * @param {dyno} [config.dyno] - a pre-configured [dyno client](https://github.com/mapbox/dyno) for connecting to DynamoDB\n * @param {s3} [config.s3] - a pre-configured [S3 client](http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html)\n * @returns {cardboard} a cardboard client\n * @example\n * var cardboard = require('cardboard')({\n *   table: 'my-cardboard-table',\n *   region: 'us-east-1',\n *   bucket: 'my-cardboard-bucket',\n *   prefix: 'my-cardboard-prefix'\n * });\n * @example\n * var cardboard = require('cardboard')({\n *   dyno: require('dyno')(dynoConfig),\n *   bucket: 'my-cardboard-bucket',\n *   prefix: 'my-cardboard-prefix'\n * });\n */\nvar Cardboard = module.exports = function(config) {\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n};",
      "path": "index.js",
      "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L39-L599"
    },
    "params": [
      {
        "title": "param",
        "description": "a configuration object",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "config"
      },
      {
        "title": "param",
        "description": "the name of a DynamoDB table to connect to",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "config.table"
      },
      {
        "title": "param",
        "description": "the AWS region containing the DynamoDB table",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "config.region"
      },
      {
        "title": "param",
        "description": "the name of an S3 bucket to use",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "config.bucket"
      },
      {
        "title": "param",
        "description": "the name of a folder within the indicated S3 bucket",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "config.prefix"
      },
      {
        "title": "param",
        "description": "a pre-configured [dyno client](https://github.com/mapbox/dyno) for connecting to DynamoDB",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "dyno"
          }
        },
        "name": "config.dyno"
      },
      {
        "title": "param",
        "description": "a pre-configured [S3 client](http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html)",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "s3"
          }
        },
        "name": "config.s3"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "a cardboard client",
        "type": {
          "type": "NameExpression",
          "name": "cardboard"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> cardboard = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'cardboard'</span>)({\n  table: <span class=\"hljs-string\">'my-cardboard-table'</span>,\n  region: <span class=\"hljs-string\">'us-east-1'</span>,\n  bucket: <span class=\"hljs-string\">'my-cardboard-bucket'</span>,\n  prefix: <span class=\"hljs-string\">'my-cardboard-prefix'</span>\n});",
      "<span class=\"hljs-keyword\">var</span> cardboard = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'cardboard'</span>)({\n  dyno: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'dyno'</span>)(dynoConfig),\n  bucket: <span class=\"hljs-string\">'my-cardboard-bucket'</span>,\n  prefix: <span class=\"hljs-string\">'my-cardboard-prefix'</span>\n});"
    ],
    "name": "Cardboard",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "Cardboard"
    ]
  },
  {
    "description": "A client configured to interact with a backend cardboard database",
    "tags": [
      {
        "title": "name",
        "name": "cardboard"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 57,
          "column": 4
        },
        "end": {
          "line": 59,
          "column": 6
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/index.js",
      "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
      "path": "index.js",
      "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L57-L59"
    },
    "name": "cardboard",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Find GeoJSON features that intersect a bounding box",
          "tags": [
            {
              "title": "param",
              "description": "the bounding box as `[west, south, east, north]`",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bbox"
            },
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "var bbox = [-120, 30, -115, 32]; // west, south, east, north\ncarboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n  if (err) throw err;\n  collection.type === 'FeatureCollection'; // true\n});"
            },
            {
              "title": "name",
              "name": "bboxQuery"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 473,
                "column": 4
              },
              "end": {
                "line": 596,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L473-L596"
          },
          "params": [
            {
              "title": "param",
              "description": "the bounding box as `[west, south, east, north]`",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bbox"
            },
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> bbox = [-<span class=\"hljs-number\">120</span>, <span class=\"hljs-number\">30</span>, -<span class=\"hljs-number\">115</span>, <span class=\"hljs-number\">32</span>]; <span class=\"hljs-comment\">// west, south, east, north</span>\ncarboard.bboxQuery(bbox, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, collection</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  collection.type === <span class=\"hljs-string\">'FeatureCollection'</span>; <span class=\"hljs-comment\">// true</span>\n});"
          ],
          "name": "bboxQuery",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "bboxQuery"
          ]
        },
        {
          "description": "Calculate metadata about a dataset",
          "tags": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n  if (err) throw err;\n  console.log(Object.keys(metadatata));\n  // [\n  //   'dataset',\n  //   'id',\n  //   'west',\n  //   'south',\n  //   'east',\n  //   'north',\n  //   'count',\n  //   'size',\n  //   'updated'\n  // ]\n});"
            },
            {
              "title": "name",
              "name": "calculateDatasetInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 457,
                "column": 4
              },
              "end": {
                "line": 459,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L457-L459"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "cardboard.calculateDatasetInfo(<span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, metadata</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.keys(metadatata));\n  <span class=\"hljs-comment\">// [</span>\n  <span class=\"hljs-comment\">//   'dataset',</span>\n  <span class=\"hljs-comment\">//   'id',</span>\n  <span class=\"hljs-comment\">//   'west',</span>\n  <span class=\"hljs-comment\">//   'south',</span>\n  <span class=\"hljs-comment\">//   'east',</span>\n  <span class=\"hljs-comment\">//   'north',</span>\n  <span class=\"hljs-comment\">//   'count',</span>\n  <span class=\"hljs-comment\">//   'size',</span>\n  <span class=\"hljs-comment\">//   'updated'</span>\n  <span class=\"hljs-comment\">// ]</span>\n});"
          ],
          "name": "calculateDatasetInfo",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "calculateDatasetInfo"
          ]
        },
        {
          "description": "Create a DynamoDB table with Cardboard's schema",
          "tags": [
            {
              "title": "param",
              "description": "the name of the table to create, if not provided, defaults to the tablename defined in client configuration.",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "string"
                }
              },
              "name": "tableName"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "// Create the cardboard table specified by the client config\ncardboard.createTable(function(err) {\n  if (err) throw err;\n});"
            },
            {
              "title": "example",
              "description": "// Create the another cardboard table\ncardboard.createTable('new-cardboard-table', function(err) {\n  if (err) throw err;\n});"
            },
            {
              "title": "name",
              "name": "createTable"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 235,
                "column": 4
              },
              "end": {
                "line": 244,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L235-L244"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the table to create, if not provided, defaults to the tablename defined in client configuration.",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "string"
                }
              },
              "name": "tableName"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "<span class=\"hljs-comment\">// Create the cardboard table specified by the client config</span>\ncardboard.createTable(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n});",
            "<span class=\"hljs-comment\">// Create the another cardboard table</span>\ncardboard.createTable(<span class=\"hljs-string\">'new-cardboard-table'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n});"
          ],
          "name": "createTable",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "createTable"
          ]
        },
        {
          "description": "Remove a single GeoJSON feature",
          "tags": [
            {
              "title": "param",
              "description": "the id for a feature",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "primary"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "// Create a point, then delete it\nvar feature = {\n  id: 'my-custom-id',\n  type: 'Feature',\n  properties: {},\n  geometry: {\n    type: 'Point',\n    coordinates: [0, 0]\n  }\n};\n\ncardboard.put(feature, 'my-dataset', function(err, result) {\n  if (err) throw err;\n\n  cardboard.del(result.id, 'my-dataset', function(err, result) {\n    if (err) throw err;\n    !!result; // true: the feature was removed\n  });\n});"
            },
            {
              "title": "example",
              "description": "// Attempt to delete a feature that does not exist\ncardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n  err.message === 'Feature does not exist'; // true\n  !!result; // false: nothing was removed\n});"
            },
            {
              "title": "name",
              "name": "del"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 165,
                "column": 4
              },
              "end": {
                "line": 173,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L165-L173"
          },
          "params": [
            {
              "title": "param",
              "description": "the id for a feature",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "primary"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "<span class=\"hljs-comment\">// Create a point, then delete it</span>\n<span class=\"hljs-keyword\">var</span> feature = {\n  id: <span class=\"hljs-string\">'my-custom-id'</span>,\n  type: <span class=\"hljs-string\">'Feature'</span>,\n  properties: {},\n  geometry: {\n    type: <span class=\"hljs-string\">'Point'</span>,\n    coordinates: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]\n  }\n};\n\ncardboard.put(feature, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, result</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n\n  cardboard.del(result.id, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, result</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n    !!result; <span class=\"hljs-comment\">// true: the feature was removed</span>\n  });\n});",
            "<span class=\"hljs-comment\">// Attempt to delete a feature that does not exist</span>\ncardboard.del(<span class=\"hljs-string\">'non-existent-feature'</span>, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, result</span>) </span>{\n  err.message === <span class=\"hljs-string\">'Feature does not exist'</span>; <span class=\"hljs-comment\">// true</span>\n  !!result; <span class=\"hljs-comment\">// false: nothing was removed</span>\n});"
          ],
          "name": "del",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "del"
          ]
        },
        {
          "description": "Remove an entire dataset",
          "tags": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "delDataset"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 269,
                "column": 4
              },
              "end": {
                "line": 281,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L269-L281"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "delDataset",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "delDataset"
          ]
        },
        {
          "description": "Retreive a single GeoJSON feature",
          "tags": [
            {
              "title": "param",
              "description": "the id for a feature",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "primary"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "// Create a point, then retrieve it.\nvar feature = {\n  type: 'Feature',\n  properties: {},\n  geometry: {\n    type: 'Point',\n    coordinates: [0, 0]\n  }\n};\n\ncardboard.put(feature, 'my-dataset', function(err, result) {\n  if (err) throw err;\n  result.geometry.coordinates = [1, 1];\n\n  cardboard.get(result.id, 'my-dataset', function(err, final) {\n    if (err) throw err;\n    final === result; // true: the feature was retrieved\n  });\n});"
            },
            {
              "title": "example",
              "description": "// Attempt to retrieve a feature that does not exist\ncardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n  err.message === 'Feature non-existent-feature does not exist'; // true\n  !!result; // false: nothing was retrieved\n});"
            },
            {
              "title": "name",
              "name": "get"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 207,
                "column": 4
              },
              "end": {
                "line": 218,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L207-L218"
          },
          "params": [
            {
              "title": "param",
              "description": "the id for a feature",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "primary"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "<span class=\"hljs-comment\">// Create a point, then retrieve it.</span>\n<span class=\"hljs-keyword\">var</span> feature = {\n  type: <span class=\"hljs-string\">'Feature'</span>,\n  properties: {},\n  geometry: {\n    type: <span class=\"hljs-string\">'Point'</span>,\n    coordinates: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]\n  }\n};\n\ncardboard.put(feature, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, result</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  result.geometry.coordinates = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>];\n\n  cardboard.get(result.id, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, final</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n    final === result; <span class=\"hljs-comment\">// true: the feature was retrieved</span>\n  });\n});",
            "<span class=\"hljs-comment\">// Attempt to retrieve a feature that does not exist</span>\ncardboard.get(<span class=\"hljs-string\">'non-existent-feature'</span>, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, result</span>) </span>{\n  err.message === <span class=\"hljs-string\">'Feature non-existent-feature does not exist'</span>; <span class=\"hljs-comment\">// true</span>\n  !!result; <span class=\"hljs-comment\">// false: nothing was retrieved</span>\n});"
          ],
          "name": "get",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "get"
          ]
        },
        {
          "description": "Get cached metadata about a dataset",
          "tags": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n  if (err) throw err;\n  console.log(Object.keys(metadatata));\n  // [\n  //   'dataset',\n  //   'id',\n  //   'west',\n  //   'south',\n  //   'east',\n  //   'north',\n  //   'count',\n  //   'size',\n  //   'updated'\n  // ]\n});"
            },
            {
              "title": "name",
              "name": "getDatasetInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 432,
                "column": 4
              },
              "end": {
                "line": 434,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L432-L434"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "cardboard.getDatasetInfo(<span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, metadata</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.keys(metadatata));\n  <span class=\"hljs-comment\">// [</span>\n  <span class=\"hljs-comment\">//   'dataset',</span>\n  <span class=\"hljs-comment\">//   'id',</span>\n  <span class=\"hljs-comment\">//   'west',</span>\n  <span class=\"hljs-comment\">//   'south',</span>\n  <span class=\"hljs-comment\">//   'east',</span>\n  <span class=\"hljs-comment\">//   'north',</span>\n  <span class=\"hljs-comment\">//   'count',</span>\n  <span class=\"hljs-comment\">//   'size',</span>\n  <span class=\"hljs-comment\">//   'updated'</span>\n  <span class=\"hljs-comment\">// ]</span>\n});"
          ],
          "name": "getDatasetInfo",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "getDatasetInfo"
          ]
        },
        {
          "description": "List the GeoJSON features that belong to a particular dataset",
          "tags": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "pagination options",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "object"
                }
              },
              "name": "pageOptions"
            },
            {
              "title": "param",
              "description": "start reading features past the provided id",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "string"
                }
              },
              "name": "pageOptions.start"
            },
            {
              "title": "param",
              "description": "maximum number of features to return",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "number"
                }
              },
              "name": "pageOptions.maxFeatures"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "// List all the features in a dataset\ncardboard.list('my-dataset', function(err, collection) {\n  if (err) throw err;\n  collection.type === 'FeatureCollection'; // true\n});"
            },
            {
              "title": "example",
              "description": "// Stream all the features in a dataset\ncardboard.list('my-dataset')\n  .on('data', function(feature) {\n    console.log('Got feature: %j', feature);\n  })\n  .on('end', function() {\n    console.log('All done!');\n  });"
            },
            {
              "title": "example",
              "description": "// List one page with a max of 10 features from a dataset\ncardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n  if (err) throw err;\n  collection.type === 'FeatureCollection'; // true\n  collection.features.length <= 10; // true\n});"
            },
            {
              "title": "example",
              "description": "// Paginate through all the features in a dataset\n(function list(startAfter) {\n  var options = { maxFeatures: 10 };\n  if (startAfter) options.start = startFrom;\n  cardabord.list('my-dataset', options, function(err, collection) {\n    if (err) throw err;\n    if (!collection.features.length) return console.log('All done!');\n\n    var lastId = collection.features.slice(-1)[0].id;\n    list(lastId);\n  });\n})();"
            },
            {
              "title": "name",
              "name": "list"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 326,
                "column": 4
              },
              "end": {
                "line": 385,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L326-L385"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "pagination options",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "object"
                }
              },
              "name": "pageOptions"
            },
            {
              "title": "param",
              "description": "start reading features past the provided id",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "string"
                }
              },
              "name": "pageOptions.start"
            },
            {
              "title": "param",
              "description": "maximum number of features to return",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "number"
                }
              },
              "name": "pageOptions.maxFeatures"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "<span class=\"hljs-comment\">// List all the features in a dataset</span>\ncardboard.list(<span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, collection</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  collection.type === <span class=\"hljs-string\">'FeatureCollection'</span>; <span class=\"hljs-comment\">// true</span>\n});",
            "<span class=\"hljs-comment\">// Stream all the features in a dataset</span>\ncardboard.list(<span class=\"hljs-string\">'my-dataset'</span>)\n  .on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">feature</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Got feature: %j'</span>, feature);\n  })\n  .on(<span class=\"hljs-string\">'end'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'All done!'</span>);\n  });",
            "<span class=\"hljs-comment\">// List one page with a max of 10 features from a dataset</span>\ncardboard.list(<span class=\"hljs-string\">'my-dataset'</span>, { maxFeatures: <span class=\"hljs-number\">10</span> }, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, collection</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  collection.type === <span class=\"hljs-string\">'FeatureCollection'</span>; <span class=\"hljs-comment\">// true</span>\n  collection.features.length &lt;= <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// true</span>\n});",
            "<span class=\"hljs-comment\">// Paginate through all the features in a dataset</span>\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">list</span>(<span class=\"hljs-params\">startAfter</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> options = { maxFeatures: <span class=\"hljs-number\">10</span> };\n  <span class=\"hljs-keyword\">if</span> (startAfter) options.start = startFrom;\n  cardabord.list(<span class=\"hljs-string\">'my-dataset'</span>, options, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, collection</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n    <span class=\"hljs-keyword\">if</span> (!collection.features.length) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'All done!'</span>);\n\n    <span class=\"hljs-keyword\">var</span> lastId = collection.features.slice(-<span class=\"hljs-number\">1</span>)[<span class=\"hljs-number\">0</span>].id;\n    list(lastId);\n  });\n})();"
          ],
          "name": "list",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "list"
          ]
        },
        {
          "description": "List datasets available in this database",
          "tags": [
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "cardboard.listDatasets(function(err, datasets) {\n  if (err) throw err;\n  Array.isArray(datasets); // true\n  console.log(datasets[0]); // 'my-dataset'\n});"
            },
            {
              "title": "name",
              "name": "listDatasets"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 397,
                "column": 4
              },
              "end": {
                "line": 409,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L397-L409"
          },
          "params": [
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "cardboard.listDatasets(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, datasets</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  <span class=\"hljs-built_in\">Array</span>.isArray(datasets); <span class=\"hljs-comment\">// true</span>\n  <span class=\"hljs-built_in\">console</span>.log(datasets[<span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// 'my-dataset'</span>\n});"
          ],
          "name": "listDatasets",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "listDatasets"
          ]
        },
        {
          "description": "Insert or update a single GeoJSON feature",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "example",
              "description": "// Create a point, allowing Cardboard to assign it an id.\nvar feature = {\n  type: 'Feature',\n  properties: {},\n  geometry: {\n    type: 'Point',\n    coordinates: [0, 0]\n  }\n};\n\ncardboard.put(feature, 'my-dataset', function(err, result) {\n  if (err) throw err;\n  !!result.id; // true: an id has been assigned\n});"
            },
            {
              "title": "example",
              "description": "// Create a point, using a custom id.\nvar feature = {\n  id: 'my-custom-id',\n  type: 'Feature',\n  properties: {},\n  geometry: {\n    type: 'Point',\n    coordinates: [0, 0]\n  }\n};\n\ncardboard.put(feature, 'my-dataset', function(err, result) {\n  if (err) throw err;\n  result.id === feature.id; // true: the custom id was preserved\n});"
            },
            {
              "title": "example",
              "description": "// Create a point, then move it.\nvar feature = {\n  type: 'Feature',\n  properties: {},\n  geometry: {\n    type: 'Point',\n    coordinates: [0, 0]\n  }\n};\n\ncardboard.put(feature, 'my-dataset', function(err, result) {\n  if (err) throw err;\n  result.geometry.coordinates = [1, 1];\n\n  cardboard.put(result, 'my-dataset', function(err, final) {\n    if (err) throw err;\n    final.geometry.coordinates[0] === 1; // true: the feature was moved\n  });\n});"
            },
            {
              "title": "name",
              "name": "put"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 118,
                "column": 4
              },
              "end": {
                "line": 131,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, allowing Cardboard to assign it an id.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   !!result.id; // true: an id has been assigned\n     * });\n     * @example\n     * // Create a point, using a custom id.\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.id === feature.id; // true: the custom id was preserved\n     * });\n     * @example\n     * // Create a point, then move it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.put(result, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final.geometry.coordinates[0] === 1; // true: the feature was moved\n     *   });\n     * });\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = geobuf.geobufToFeature(encoded[1].Body);\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then delete it\n     * var feature = {\n     *   id: 'my-custom-id',\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *\n     *   cardboard.del(result.id, 'my-dataset', function(err, result) {\n     *     if (err) throw err;\n     *     !!result; // true: the feature was removed\n     *   });\n     * });\n     * @example\n     * // Attempt to delete a feature that does not exist\n     * cardboard.del('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature does not exist'; // true\n     *   !!result; // false: nothing was removed\n     * });\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create a point, then retrieve it.\n     * var feature = {\n     *   type: 'Feature',\n     *   properties: {},\n     *   geometry: {\n     *     type: 'Point',\n     *     coordinates: [0, 0]\n     *   }\n     * };\n     *\n     * cardboard.put(feature, 'my-dataset', function(err, result) {\n     *   if (err) throw err;\n     *   result.geometry.coordinates = [1, 1];\n     *\n     *   cardboard.get(result.id, 'my-dataset', function(err, final) {\n     *     if (err) throw err;\n     *     final === result; // true: the feature was retrieved\n     *   });\n     * });\n     * @example\n     * // Attempt to retrieve a feature that does not exist\n     * cardboard.get('non-existent-feature', 'my-dataset', function(err, result) {\n     *   err.message === 'Feature non-existent-feature does not exist'; // true\n     *   !!result; // false: nothing was retrieved\n     * });\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // Create the cardboard table specified by the client config\n     * cardboard.createTable(function(err) {\n     *   if (err) throw err;\n     * });\n     * @example\n     * // Create the another cardboard table\n     * cardboard.createTable('new-cardboard-table', function(err) {\n     *   if (err) throw err;\n     * });\n     */\n    cardboard.createTable = function(tableName, callback) {\n        if (typeof tableName === 'function') {\n            callback = tableName;\n            tableName = null;\n        }\n\n        var table = require('./lib/table.json');\n        table.TableName = tableName || config.table;\n        config.dyno.createTable(table, callback);\n    };\n\n    /**\n     * List the ids available in a dataset\n     * @private\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    function listIds(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} };\n        var opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    }\n\n    /**\n     * Remove an entire dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.delDataset = function(dataset, callback) {\n        listIds(dataset, function(err, res) {\n            var keys = res.map(function(id) {\n                return { dataset: dataset, id: 'id!' + id };\n            });\n\n            keys.push({ dataset: dataset, id: 'metadata!' + dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {object} [pageOptions] - pagination options\n     * @param {string} [pageOptions.start] - start reading features past the provided id\n     * @param {number} [pageOptions.maxFeatures] - maximum number of features to return\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * // List all the features in a dataset\n     * cardboard.list('my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     * @example\n     * // Stream all the features in a dataset\n     * cardboard.list('my-dataset')\n     *   .on('data', function(feature) {\n     *     console.log('Got feature: %j', feature);\n     *   })\n     *   .on('end', function() {\n     *     console.log('All done!');\n     *   });\n     * @example\n     * // List one page with a max of 10 features from a dataset\n     * cardboard.list('my-dataset', { maxFeatures: 10 }, function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     *   collection.features.length <= 10; // true\n     * });\n     * @example\n     * // Paginate through all the features in a dataset\n     * (function list(startAfter) {\n     *   var options = { maxFeatures: 10 };\n     *   if (startAfter) options.start = startFrom;\n     *   cardabord.list('my-dataset', options, function(err, collection) {\n     *     if (err) throw err;\n     *     if (!collection.features.length) return console.log('All done!');\n     *\n     *     var lastId = collection.features.slice(-1)[0].id;\n     *     list(lastId);\n     *   });\n     * })();\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        pageOptions = pageOptions || {};\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n\n        if (!callback) {\n            var resolver = new stream.Transform({ objectMode: true, highWaterMark: 50 });\n\n            resolver.items = [];\n\n            resolver._resolve = function(callback) {\n                utils.resolveFeatures(resolver.items, function(err, collection) {\n                    if (err) return callback(err);\n\n                    resolver.items = [];\n\n                    collection.features.forEach(function(feature) {\n                        resolver.push(feature);\n                    });\n\n                    callback();\n                });\n            };\n\n            resolver._transform = function(item, enc, callback) {\n                resolver.items.push(item);\n                if (resolver.items.length < 25) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            resolver._flush = function(callback) {\n                if (!resolver.items.length) return callback();\n\n                resolver._resolve(callback);\n            };\n\n            return config.dyno.query(query)\n                .on('error', function(err) { resolver.emit('error', err); })\n              .pipe(resolver);\n        }\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.listDatasets(function(err, datasets) {\n     *   if (err) throw err;\n     *   Array.isArray(datasets); // true\n     *   console.log(datasets[0]); // 'my-dataset'\n     * });\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n\n            var datasets = _.uniq(items.map(function(item) {\n                return item.dataset;\n            }));\n\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.getDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * cardboard.calculateDatasetInfo('my-dataset', function(err, metadata) {\n     *   if (err) throw err;\n     *   console.log(Object.keys(metadatata));\n     *   // [\n     *   //   'dataset',\n     *   //   'id',\n     *   //   'west',\n     *   //   'south',\n     *   //   'east',\n     *   //   'north',\n     *   //   'count',\n     *   //   'size',\n     *   //   'updated'\n     *   // ]\n     * });\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     * @example\n     * var bbox = [-120, 30, -115, 32]; // west, south, east, north\n     * carboard.bboxQuery(bbox, 'my-dataset', function(err, collection) {\n     *   if (err) throw err;\n     *   collection.type === 'FeatureCollection'; // true\n     * });\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n            });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { BEGINS_WITH: 'cell!' + tileKey },\n                dataset: { EQ: dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter: {\n                    west: { LE: bbox[2] },\n                    east: { GE: bbox[0] },\n                    north: { GE: bbox[1] },\n                    south: { LE: bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { EQ: 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) break;\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    return cardboard;\n}",
            "path": "index.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/index.js#L118-L131"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "examples": [
            "<span class=\"hljs-comment\">// Create a point, allowing Cardboard to assign it an id.</span>\n<span class=\"hljs-keyword\">var</span> feature = {\n  type: <span class=\"hljs-string\">'Feature'</span>,\n  properties: {},\n  geometry: {\n    type: <span class=\"hljs-string\">'Point'</span>,\n    coordinates: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]\n  }\n};\n\ncardboard.put(feature, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, result</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  !!result.id; <span class=\"hljs-comment\">// true: an id has been assigned</span>\n});",
            "<span class=\"hljs-comment\">// Create a point, using a custom id.</span>\n<span class=\"hljs-keyword\">var</span> feature = {\n  id: <span class=\"hljs-string\">'my-custom-id'</span>,\n  type: <span class=\"hljs-string\">'Feature'</span>,\n  properties: {},\n  geometry: {\n    type: <span class=\"hljs-string\">'Point'</span>,\n    coordinates: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]\n  }\n};\n\ncardboard.put(feature, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, result</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  result.id === feature.id; <span class=\"hljs-comment\">// true: the custom id was preserved</span>\n});",
            "<span class=\"hljs-comment\">// Create a point, then move it.</span>\n<span class=\"hljs-keyword\">var</span> feature = {\n  type: <span class=\"hljs-string\">'Feature'</span>,\n  properties: {},\n  geometry: {\n    type: <span class=\"hljs-string\">'Point'</span>,\n    coordinates: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]\n  }\n};\n\ncardboard.put(feature, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, result</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n  result.geometry.coordinates = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>];\n\n  cardboard.put(result, <span class=\"hljs-string\">'my-dataset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, final</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n    final.geometry.coordinates[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true: the feature was moved</span>\n  });\n});"
          ],
          "name": "put",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "put"
          ]
        }
      ]
    },
    "path": [
      "cardboard"
    ]
  },
  {
    "description": "A module for batch requests",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "cardboard.batch"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 17,
          "column": 4
        },
        "end": {
          "line": 17,
          "column": 19
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/lib/batch.js",
      "code": "{\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    var utils = require('./utils')(config);\n\n    /**\n     * A module for batch requests\n     * @name cardboard.batch\n     */\n    var batch = {};\n\n    /**\n     * Insert or update a set of GeoJSON features\n     * @static\n     * @memberof cardboard.batch\n     * @param {object} collection - a GeoJSON FeatureCollection containing features to insert and/or update\n     * @param {string} dataset - the name of the dataset that these features belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.put = function(collection, dataset, callback) {\n        var records = [];\n        var geobufs = [];\n        var s3objects = [];\n\n        var encoded;\n        var q = queue(150);\n\n        for (var i = 0; i < collection.features.length; i++) {\n            try { encoded = utils.toDatabaseRecord(collection.features[i], dataset); }\n            catch (err) { return callback(err); }\n\n            records.push(encoded[0]);\n            geobufs.push(encoded[1].Body);\n            q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        }\n\n        q.awaitAll(function(err) {\n            if (err) return callback(err);\n            config.dyno.putItems(records, function(err, items) {\n                if (err) return callback(err);\n\n                var features = geobufs.map(geobuf.geobufToFeature.bind(geobuf));\n\n                callback(null, { type: 'FeatureCollection', features: features });\n            });\n        });\n    };\n\n    /**\n     * Remove a set of features\n     * @static\n     * @memberof cardboard.batch\n     * @param {string[]} ids - an array of feature ids to remove\n     * @param {string} dataset - the name of the dataset that these features belong to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.remove = function(ids, dataset, callback) {\n        var keys = ids.map(function(id) {\n            return { dataset: dataset, id: 'id!' + id };\n        });\n\n        config.dyno.deleteItems(keys, function(err) {\n            callback(err);\n        });\n    };\n\n    return batch;\n}",
      "path": "lib/batch.js",
      "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/batch.js#L17-L17"
    },
    "name": "cardboard.batch",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Insert or update a set of GeoJSON features",
          "tags": [
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "cardboard.batch"
            },
            {
              "title": "param",
              "description": "a GeoJSON FeatureCollection containing features to insert and/or update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "collection"
            },
            {
              "title": "param",
              "description": "the name of the dataset that these features belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "put"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 27,
                "column": 4
              },
              "end": {
                "line": 54,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/batch.js",
            "code": "{\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    var utils = require('./utils')(config);\n\n    /**\n     * A module for batch requests\n     * @name cardboard.batch\n     */\n    var batch = {};\n\n    /**\n     * Insert or update a set of GeoJSON features\n     * @static\n     * @memberof cardboard.batch\n     * @param {object} collection - a GeoJSON FeatureCollection containing features to insert and/or update\n     * @param {string} dataset - the name of the dataset that these features belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.put = function(collection, dataset, callback) {\n        var records = [];\n        var geobufs = [];\n        var s3objects = [];\n\n        var encoded;\n        var q = queue(150);\n\n        for (var i = 0; i < collection.features.length; i++) {\n            try { encoded = utils.toDatabaseRecord(collection.features[i], dataset); }\n            catch (err) { return callback(err); }\n\n            records.push(encoded[0]);\n            geobufs.push(encoded[1].Body);\n            q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        }\n\n        q.awaitAll(function(err) {\n            if (err) return callback(err);\n            config.dyno.putItems(records, function(err, items) {\n                if (err) return callback(err);\n\n                var features = geobufs.map(geobuf.geobufToFeature.bind(geobuf));\n\n                callback(null, { type: 'FeatureCollection', features: features });\n            });\n        });\n    };\n\n    /**\n     * Remove a set of features\n     * @static\n     * @memberof cardboard.batch\n     * @param {string[]} ids - an array of feature ids to remove\n     * @param {string} dataset - the name of the dataset that these features belong to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.remove = function(ids, dataset, callback) {\n        var keys = ids.map(function(id) {\n            return { dataset: dataset, id: 'id!' + id };\n        });\n\n        config.dyno.deleteItems(keys, function(err) {\n            callback(err);\n        });\n    };\n\n    return batch;\n}",
            "path": "lib/batch.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/batch.js#L27-L54"
          },
          "scope": "static",
          "memberof": "cardboard.batch",
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON FeatureCollection containing features to insert and/or update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "collection"
            },
            {
              "title": "param",
              "description": "the name of the dataset that these features belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "put",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard.batch",
            "put"
          ]
        },
        {
          "description": "Remove a set of features",
          "tags": [
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "cardboard.batch"
            },
            {
              "title": "param",
              "description": "an array of feature ids to remove",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              },
              "name": "ids"
            },
            {
              "title": "param",
              "description": "the name of the dataset that these features belong to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "remove"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 64,
                "column": 4
              },
              "end": {
                "line": 72,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/batch.js",
            "code": "{\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    var utils = require('./utils')(config);\n\n    /**\n     * A module for batch requests\n     * @name cardboard.batch\n     */\n    var batch = {};\n\n    /**\n     * Insert or update a set of GeoJSON features\n     * @static\n     * @memberof cardboard.batch\n     * @param {object} collection - a GeoJSON FeatureCollection containing features to insert and/or update\n     * @param {string} dataset - the name of the dataset that these features belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.put = function(collection, dataset, callback) {\n        var records = [];\n        var geobufs = [];\n        var s3objects = [];\n\n        var encoded;\n        var q = queue(150);\n\n        for (var i = 0; i < collection.features.length; i++) {\n            try { encoded = utils.toDatabaseRecord(collection.features[i], dataset); }\n            catch (err) { return callback(err); }\n\n            records.push(encoded[0]);\n            geobufs.push(encoded[1].Body);\n            q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        }\n\n        q.awaitAll(function(err) {\n            if (err) return callback(err);\n            config.dyno.putItems(records, function(err, items) {\n                if (err) return callback(err);\n\n                var features = geobufs.map(geobuf.geobufToFeature.bind(geobuf));\n\n                callback(null, { type: 'FeatureCollection', features: features });\n            });\n        });\n    };\n\n    /**\n     * Remove a set of features\n     * @static\n     * @memberof cardboard.batch\n     * @param {string[]} ids - an array of feature ids to remove\n     * @param {string} dataset - the name of the dataset that these features belong to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.remove = function(ids, dataset, callback) {\n        var keys = ids.map(function(id) {\n            return { dataset: dataset, id: 'id!' + id };\n        });\n\n        config.dyno.deleteItems(keys, function(err) {\n            callback(err);\n        });\n    };\n\n    return batch;\n}",
            "path": "lib/batch.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/batch.js#L64-L72"
          },
          "scope": "static",
          "memberof": "cardboard.batch",
          "params": [
            {
              "title": "param",
              "description": "an array of feature ids to remove",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              },
              "name": "ids"
            },
            {
              "title": "param",
              "description": "the name of the dataset that these features belong to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "remove",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard.batch",
            "remove"
          ]
        }
      ]
    },
    "path": [
      "cardboard.batch"
    ]
  },
  {
    "description": "A client for interacting with the metadata for a dataset",
    "tags": [
      {
        "title": "name",
        "name": "metadata"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 10,
          "column": 4
        },
        "end": {
          "line": 10,
          "column": 22
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
      "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { NULL: [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        var opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = ['west', 'south', 'east', 'north'];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {GT: bound } : {LT: bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { NOT_NULL: [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from);\n        var toInfo = metadata.getFeatureInfo(to);\n        var bounds = toInfo.bounds;\n        var size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}",
      "path": "lib/metadata.js",
      "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/metadata.js#L10-L10"
    },
    "name": "metadata",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature being added to the dataset",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "addFeature"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 166,
                "column": 4
              },
              "end": {
                "line": 177,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { NULL: [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        var opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = ['west', 'south', 'east', 'north'];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {GT: bound } : {LT: bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { NOT_NULL: [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from);\n        var toInfo = metadata.getFeatureInfo(to);\n        var bounds = toInfo.bounds;\n        var size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}",
            "path": "lib/metadata.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/metadata.js#L166-L177"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature being added to the dataset",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "addFeature",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "addFeature"
          ]
        },
        {
          "description": "Find all features in a dataset and bring metadata record up-to-date",
          "tags": [
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "calculateInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 87,
                "column": 4
              },
              "end": {
                "line": 120,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { NULL: [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        var opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = ['west', 'south', 'east', 'north'];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {GT: bound } : {LT: bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { NOT_NULL: [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from);\n        var toInfo = metadata.getFeatureInfo(to);\n        var bounds = toInfo.bounds;\n        var size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}",
            "path": "lib/metadata.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/metadata.js#L87-L120"
          },
          "params": [
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "calculateInfo",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "calculateInfo"
          ]
        },
        {
          "description": "Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature to remove from the dataset",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "deleteFeature"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 202,
                "column": 4
              },
              "end": {
                "line": 208,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { NULL: [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        var opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = ['west', 'south', 'east', 'north'];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {GT: bound } : {LT: bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { NOT_NULL: [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from);\n        var toInfo = metadata.getFeatureInfo(to);\n        var bounds = toInfo.bounds;\n        var size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}",
            "path": "lib/metadata.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/metadata.js#L202-L208"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature to remove from the dataset",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "deleteFeature",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "deleteFeature"
          ]
        },
        {
          "description": "Return the details for a given GeoJSON feature",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "returns",
              "description": "an object describing the feature's size and extent",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "name",
              "name": "getFeatureInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 48,
                "column": 4
              },
              "end": {
                "line": 58,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { NULL: [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        var opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = ['west', 'south', 'east', 'north'];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {GT: bound } : {LT: bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { NOT_NULL: [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from);\n        var toInfo = metadata.getFeatureInfo(to);\n        var bounds = toInfo.bounds;\n        var size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}",
            "path": "lib/metadata.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/metadata.js#L48-L58"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "an object describing the feature's size and extent",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "name": "getFeatureInfo",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "getFeatureInfo"
          ]
        },
        {
          "description": "Return dataset metadata or an empty object",
          "tags": [
            {
              "title": "param",
              "description": "a callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 35,
                "column": 4
              },
              "end": {
                "line": 41,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { NULL: [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        var opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = ['west', 'south', 'east', 'north'];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {GT: bound } : {LT: bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { NOT_NULL: [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from);\n        var toInfo = metadata.getFeatureInfo(to);\n        var bounds = toInfo.bounds;\n        var size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}",
            "path": "lib/metadata.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/metadata.js#L35-L41"
          },
          "params": [
            {
              "title": "param",
              "description": "a callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getInfo",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "getInfo"
          ]
        },
        {
          "description": "Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature representing the state of the feature *before* the update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "from"
            },
            {
              "title": "param",
              "description": "a GeoJSON feature representing the state of the feature *after* the update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "to"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "updateFeature"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 185,
                "column": 4
              },
              "end": {
                "line": 195,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { NULL: [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        var opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = ['west', 'south', 'east', 'north'];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {GT: bound } : {LT: bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { NOT_NULL: [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from);\n        var toInfo = metadata.getFeatureInfo(to);\n        var bounds = toInfo.bounds;\n        var size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}",
            "path": "lib/metadata.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/metadata.js#L185-L195"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature representing the state of the feature *before* the update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "from"
            },
            {
              "title": "param",
              "description": "a GeoJSON feature representing the state of the feature *after* the update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "to"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "updateFeature",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "updateFeature"
          ]
        }
      ]
    },
    "path": [
      "metadata"
    ]
  },
  {
    "description": "A module containing internal utility functions",
    "tags": [
      {
        "title": "name",
        "name": "utils"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 14,
          "column": 4
        },
        "end": {
          "line": 14,
          "column": 19
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/lib/utils.js",
      "code": "{\n    /**\n     * A module containing internal utility functions\n     */\n    var utils = {};\n\n    /**\n     * Convert a set of backend records into a GeoJSON features\n     * @param {object[]} dynamoRecords - an array of items returned from DynamoDB in simplified JSON format\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.resolveFeatures = function(dynamoRecords, callback) {\n        var q = queue(100); // Concurrency of S3 requests\n\n        dynamoRecords.forEach(function(dynamoRecord) {\n            var val = dynamoRecord.val;\n            var uri = url.parse(dynamoRecord.s3url);\n\n            q.defer(function(next) {\n                if (val) return next(null, geobuf.geobufToFeature(val));\n\n                config.s3.getObject({\n                    Bucket: uri.host,\n                    Key: uri.pathname.substr(1)\n                }, function(err, data) {\n                    if (err) return next(err);\n                    next(null, geobuf.geobufToFeature(data.Body));\n                });\n            });\n        });\n\n        q.awaitAll(function(err, results) {\n            if (err) return callback(err);\n            callback(null, utils.featureCollection(results));\n        });\n    };\n\n    /**\n     * Wraps an array of GeoJSON features in a FeatureCollection\n     * @private\n     * @param {object[]} records - an array of GeoJSON features\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.featureCollection = function(records, callback) {\n        return geojsonNormalize({ type: 'FeatureCollection', features: records });\n    };\n\n    /**\n     * Converts a single GeoJSON feature into backend format\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset the feature belongs to\n     * @returns {object[]} the first element is a DynamoDB record suitable for inserting via `dyno.putItem`, the second are parameters suitable for uploading via `s3.putObject`.\n     */\n    utils.toDatabaseRecord = function(feature, dataset) {\n        var f = feature.hasOwnProperty('id') ? _.clone(feature) : _.extend({ id: cuid() }, feature);\n        var primary = f.id;\n\n        if (!f.geometry || !f.geometry.coordinates)\n            throw new Error('Unlocated features can not be stored.');\n\n        var info = Metadata(config.dyno, dataset).getFeatureInfo(f);\n        var buf = geobuf.featureToGeobuf(f).toBuffer();\n        var tile = tilebelt.bboxToTile([info.west, info.south, info.east, info.north]);\n        var cell = tilebelt.tileToQuadkey(tile);\n        var useS3 = buf.length >= config.MAX_GEOMETRY_SIZE;\n        var s3Key = [config.prefix, dataset, primary, +new Date()].join('/');\n        var s3Params = { Bucket: config.bucket, Key: s3Key, Body: buf };\n\n        var item = {\n            dataset: dataset,\n            id: 'id!' + primary,\n            cell: 'cell!' + cell,\n            size: info.size,\n            west: truncateNum(info.west),\n            south: truncateNum(info.south),\n            east: truncateNum(info.east),\n            north: truncateNum(info.north),\n            s3url: ['s3:/', config.bucket, s3Key].join('/')\n        };\n\n        if (!useS3) item.val = buf;\n        return [item, s3Params];\n    };\n\n    return utils;\n}",
      "path": "lib/utils.js",
      "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/utils.js#L14-L14"
    },
    "name": "utils",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Convert a set of backend records into a GeoJSON features",
          "tags": [
            {
              "title": "param",
              "description": "an array of items returned from DynamoDB in simplified JSON format",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "object"
                  }
                ]
              },
              "name": "dynamoRecords"
            },
            {
              "title": "param",
              "description": "a callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "resolveFeatures"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "utils"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 21,
                "column": 4
              },
              "end": {
                "line": 45,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/utils.js",
            "code": "{\n    /**\n     * A module containing internal utility functions\n     */\n    var utils = {};\n\n    /**\n     * Convert a set of backend records into a GeoJSON features\n     * @param {object[]} dynamoRecords - an array of items returned from DynamoDB in simplified JSON format\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.resolveFeatures = function(dynamoRecords, callback) {\n        var q = queue(100); // Concurrency of S3 requests\n\n        dynamoRecords.forEach(function(dynamoRecord) {\n            var val = dynamoRecord.val;\n            var uri = url.parse(dynamoRecord.s3url);\n\n            q.defer(function(next) {\n                if (val) return next(null, geobuf.geobufToFeature(val));\n\n                config.s3.getObject({\n                    Bucket: uri.host,\n                    Key: uri.pathname.substr(1)\n                }, function(err, data) {\n                    if (err) return next(err);\n                    next(null, geobuf.geobufToFeature(data.Body));\n                });\n            });\n        });\n\n        q.awaitAll(function(err, results) {\n            if (err) return callback(err);\n            callback(null, utils.featureCollection(results));\n        });\n    };\n\n    /**\n     * Wraps an array of GeoJSON features in a FeatureCollection\n     * @private\n     * @param {object[]} records - an array of GeoJSON features\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.featureCollection = function(records, callback) {\n        return geojsonNormalize({ type: 'FeatureCollection', features: records });\n    };\n\n    /**\n     * Converts a single GeoJSON feature into backend format\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset the feature belongs to\n     * @returns {object[]} the first element is a DynamoDB record suitable for inserting via `dyno.putItem`, the second are parameters suitable for uploading via `s3.putObject`.\n     */\n    utils.toDatabaseRecord = function(feature, dataset) {\n        var f = feature.hasOwnProperty('id') ? _.clone(feature) : _.extend({ id: cuid() }, feature);\n        var primary = f.id;\n\n        if (!f.geometry || !f.geometry.coordinates)\n            throw new Error('Unlocated features can not be stored.');\n\n        var info = Metadata(config.dyno, dataset).getFeatureInfo(f);\n        var buf = geobuf.featureToGeobuf(f).toBuffer();\n        var tile = tilebelt.bboxToTile([info.west, info.south, info.east, info.north]);\n        var cell = tilebelt.tileToQuadkey(tile);\n        var useS3 = buf.length >= config.MAX_GEOMETRY_SIZE;\n        var s3Key = [config.prefix, dataset, primary, +new Date()].join('/');\n        var s3Params = { Bucket: config.bucket, Key: s3Key, Body: buf };\n\n        var item = {\n            dataset: dataset,\n            id: 'id!' + primary,\n            cell: 'cell!' + cell,\n            size: info.size,\n            west: truncateNum(info.west),\n            south: truncateNum(info.south),\n            east: truncateNum(info.east),\n            north: truncateNum(info.north),\n            s3url: ['s3:/', config.bucket, s3Key].join('/')\n        };\n\n        if (!useS3) item.val = buf;\n        return [item, s3Params];\n    };\n\n    return utils;\n}",
            "path": "lib/utils.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/utils.js#L21-L45"
          },
          "params": [
            {
              "title": "param",
              "description": "an array of items returned from DynamoDB in simplified JSON format",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "object"
                  }
                ]
              },
              "name": "dynamoRecords"
            },
            {
              "title": "param",
              "description": "a callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "resolveFeatures",
          "kind": "function",
          "memberof": "utils",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "utils",
            "resolveFeatures"
          ]
        },
        {
          "description": "Converts a single GeoJSON feature into backend format",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "the name of the dataset the feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "returns",
              "description": "the first element is a DynamoDB record suitable for inserting via `dyno.putItem`, the second are parameters suitable for uploading via `s3.putObject`.",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "object"
                  }
                ]
              }
            },
            {
              "title": "name",
              "name": "toDatabaseRecord"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "utils"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 63,
                "column": 4
              },
              "end": {
                "line": 92,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/utils.js",
            "code": "{\n    /**\n     * A module containing internal utility functions\n     */\n    var utils = {};\n\n    /**\n     * Convert a set of backend records into a GeoJSON features\n     * @param {object[]} dynamoRecords - an array of items returned from DynamoDB in simplified JSON format\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.resolveFeatures = function(dynamoRecords, callback) {\n        var q = queue(100); // Concurrency of S3 requests\n\n        dynamoRecords.forEach(function(dynamoRecord) {\n            var val = dynamoRecord.val;\n            var uri = url.parse(dynamoRecord.s3url);\n\n            q.defer(function(next) {\n                if (val) return next(null, geobuf.geobufToFeature(val));\n\n                config.s3.getObject({\n                    Bucket: uri.host,\n                    Key: uri.pathname.substr(1)\n                }, function(err, data) {\n                    if (err) return next(err);\n                    next(null, geobuf.geobufToFeature(data.Body));\n                });\n            });\n        });\n\n        q.awaitAll(function(err, results) {\n            if (err) return callback(err);\n            callback(null, utils.featureCollection(results));\n        });\n    };\n\n    /**\n     * Wraps an array of GeoJSON features in a FeatureCollection\n     * @private\n     * @param {object[]} records - an array of GeoJSON features\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.featureCollection = function(records, callback) {\n        return geojsonNormalize({ type: 'FeatureCollection', features: records });\n    };\n\n    /**\n     * Converts a single GeoJSON feature into backend format\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset the feature belongs to\n     * @returns {object[]} the first element is a DynamoDB record suitable for inserting via `dyno.putItem`, the second are parameters suitable for uploading via `s3.putObject`.\n     */\n    utils.toDatabaseRecord = function(feature, dataset) {\n        var f = feature.hasOwnProperty('id') ? _.clone(feature) : _.extend({ id: cuid() }, feature);\n        var primary = f.id;\n\n        if (!f.geometry || !f.geometry.coordinates)\n            throw new Error('Unlocated features can not be stored.');\n\n        var info = Metadata(config.dyno, dataset).getFeatureInfo(f);\n        var buf = geobuf.featureToGeobuf(f).toBuffer();\n        var tile = tilebelt.bboxToTile([info.west, info.south, info.east, info.north]);\n        var cell = tilebelt.tileToQuadkey(tile);\n        var useS3 = buf.length >= config.MAX_GEOMETRY_SIZE;\n        var s3Key = [config.prefix, dataset, primary, +new Date()].join('/');\n        var s3Params = { Bucket: config.bucket, Key: s3Key, Body: buf };\n\n        var item = {\n            dataset: dataset,\n            id: 'id!' + primary,\n            cell: 'cell!' + cell,\n            size: info.size,\n            west: truncateNum(info.west),\n            south: truncateNum(info.south),\n            east: truncateNum(info.east),\n            north: truncateNum(info.north),\n            s3url: ['s3:/', config.bucket, s3Key].join('/')\n        };\n\n        if (!useS3) item.val = buf;\n        return [item, s3Params];\n    };\n\n    return utils;\n}",
            "path": "lib/utils.js",
            "github": "https://github.com/mapbox/cardboard/blob/1a190581b0933f6159013b77ac82bd59c6a551bb/lib/utils.js#L63-L92"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "the name of the dataset the feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the first element is a DynamoDB record suitable for inserting via `dyno.putItem`, the second are parameters suitable for uploading via `s3.putObject`.",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "object"
                  }
                ]
              }
            }
          ],
          "name": "toDatabaseRecord",
          "kind": "function",
          "memberof": "utils",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "utils",
            "toDatabaseRecord"
          ]
        }
      ]
    },
    "path": [
      "utils"
    ]
  }
]