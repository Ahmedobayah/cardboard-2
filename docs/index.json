[
  {
    "description": "",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "CardboardClientConfiguration"
      },
      {
        "title": "type",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "object"
        }
      },
      {
        "title": "property",
        "description": "the name of a DynamoDB table to connect to",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "property",
        "description": "the AWS region containing the DynamoDB table",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "region"
      },
      {
        "title": "property",
        "description": "the name of an S3 bucket to use",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "bucket"
      },
      {
        "title": "property",
        "description": "the name of a folder within the indicated S3 bucket",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "prefix"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 51,
          "column": 0
        },
        "end": {
          "line": 380,
          "column": 2
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/index.js",
      "code": "var through = require('through2');\nvar _ = require('lodash');\nvar geojsonStream = require('geojson-stream');\nvar geojsonNormalize = require('geojson-normalize');\nvar concat = require('concat-stream');\nvar coverOpts = require('./lib/coveropts');\nvar Metadata = require('./lib/metadata');\nvar uniq = require('uniq');\nvar geobuf = require('geobuf');\nvar log = require('debug')('cardboard');\nvar queue = require('queue-async');\nvar Dyno = require('dyno');\nvar AWS = require('aws-sdk');\nvar extent = require('geojson-extent');\nvar cuid = require('cuid');\nvar url = require('url');\nvar tilebelt = require('tilebelt');\n\nvar MAX_GEOMETRY_SIZE = 1024*10;  //10KB\nvar LARGE_INDEX_DISTANCE = 50; //bbox more then 100 miles corner to corner.\n\n// /**\n//  * Handle the response from inserting or updating a feature\n//  * @callback cardboard~putCallback\n//  * @param {object} err - an error object, set to null if no error occurred\n//  * @param {object} feature - a stored version of the GeoJSON feature that was inserted or updated\n//  */\n\n/**\n * @name PaginationOptions\n * @type {object}\n * @property {string} start - start reading features past the provided id\n * @property {number} maxFeatures - maximum number of features to return\n */\n\n/**\n * @name CardboardClientConfiguration\n * @type {object}\n * @property {string} table - the name of a DynamoDB table to connect to\n * @property {string} region - the AWS region containing the DynamoDB table\n * @property {string} bucket - the name of an S3 bucket to use\n * @property {string} prefix - the name of a folder within the indicated S3 bucket\n */\n\n/**\n * Creates a cardboard client\n * @name CardboardClientFactory\n * @param {CardboardClientConfiguration} config - a configuration object\n * @returns {cardboard} a cardboard client\n */\nmodule.exports = function(config) {\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n};\n\nfunction indexLevel(feature) {\n    var bbox = extent(feature);\n    var sw = point(bbox[0], bbox[1]);\n    var ne = point(bbox[2], bbox[3]);\n    var dist = distance(sw, ne, 'miles');\n    return dist >= LARGE_INDEX_DISTANCE ? 0 : 1;\n}\n\nfunction truncateNum(num, digits) {\n    digits = digits || 6;\n    var exp = Math.pow(10, digits);\n    return Math.round(exp * num) / exp;\n}"
    },
    "name": "CardboardClientConfiguration",
    "properties": [
      {
        "title": "property",
        "description": "the name of a DynamoDB table to connect to",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "property",
        "description": "the AWS region containing the DynamoDB table",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "region"
      },
      {
        "title": "property",
        "description": "the name of an S3 bucket to use",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "bucket"
      },
      {
        "title": "property",
        "description": "the name of a folder within the indicated S3 bucket",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "prefix"
      }
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "CardboardClientConfiguration"
    ]
  },
  {
    "description": "Creates a cardboard client",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "CardboardClientFactory"
      },
      {
        "title": "param",
        "description": "a configuration object",
        "type": {
          "type": "NameExpression",
          "name": "CardboardClientConfiguration"
        },
        "name": "config"
      },
      {
        "title": "returns",
        "description": "a cardboard client",
        "type": {
          "type": "NameExpression",
          "name": "cardboard"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 51,
          "column": 0
        },
        "end": {
          "line": 380,
          "column": 2
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/index.js",
      "code": "var through = require('through2');\nvar _ = require('lodash');\nvar geojsonStream = require('geojson-stream');\nvar geojsonNormalize = require('geojson-normalize');\nvar concat = require('concat-stream');\nvar coverOpts = require('./lib/coveropts');\nvar Metadata = require('./lib/metadata');\nvar uniq = require('uniq');\nvar geobuf = require('geobuf');\nvar log = require('debug')('cardboard');\nvar queue = require('queue-async');\nvar Dyno = require('dyno');\nvar AWS = require('aws-sdk');\nvar extent = require('geojson-extent');\nvar cuid = require('cuid');\nvar url = require('url');\nvar tilebelt = require('tilebelt');\n\nvar MAX_GEOMETRY_SIZE = 1024*10;  //10KB\nvar LARGE_INDEX_DISTANCE = 50; //bbox more then 100 miles corner to corner.\n\n// /**\n//  * Handle the response from inserting or updating a feature\n//  * @callback cardboard~putCallback\n//  * @param {object} err - an error object, set to null if no error occurred\n//  * @param {object} feature - a stored version of the GeoJSON feature that was inserted or updated\n//  */\n\n/**\n * @name PaginationOptions\n * @type {object}\n * @property {string} start - start reading features past the provided id\n * @property {number} maxFeatures - maximum number of features to return\n */\n\n/**\n * @name CardboardClientConfiguration\n * @type {object}\n * @property {string} table - the name of a DynamoDB table to connect to\n * @property {string} region - the AWS region containing the DynamoDB table\n * @property {string} bucket - the name of an S3 bucket to use\n * @property {string} prefix - the name of a folder within the indicated S3 bucket\n */\n\n/**\n * Creates a cardboard client\n * @name CardboardClientFactory\n * @param {CardboardClientConfiguration} config - a configuration object\n * @returns {cardboard} a cardboard client\n */\nmodule.exports = function(config) {\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n};\n\nfunction indexLevel(feature) {\n    var bbox = extent(feature);\n    var sw = point(bbox[0], bbox[1]);\n    var ne = point(bbox[2], bbox[3]);\n    var dist = distance(sw, ne, 'miles');\n    return dist >= LARGE_INDEX_DISTANCE ? 0 : 1;\n}\n\nfunction truncateNum(num, digits) {\n    digits = digits || 6;\n    var exp = Math.pow(10, digits);\n    return Math.round(exp * num) / exp;\n}"
    },
    "name": "CardboardClientFactory",
    "params": [
      {
        "title": "param",
        "description": "a configuration object",
        "type": {
          "type": "NameExpression",
          "name": "CardboardClientConfiguration"
        },
        "name": "config"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "a cardboard client",
        "type": {
          "type": "NameExpression",
          "name": "cardboard"
        }
      }
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "CardboardClientFactory"
    ]
  },
  {
    "description": "Create a metadata client",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "MetadataClientFactory"
      },
      {
        "title": "param",
        "description": "a dyno client",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "dyno"
      },
      {
        "title": "param",
        "description": "the name of the dataset",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "dataset"
      },
      {
        "title": "returns",
        "description": "a metadata client",
        "type": {
          "type": "NameExpression",
          "name": "metadata"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 12,
          "column": 0
        },
        "end": {
          "line": 218,
          "column": 2
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
      "code": "var queue = require('queue-async');\nvar extent = require('geojson-extent');\nvar through = require('through2');\n\n/**\n * Create a metadata client\n * @name MetadataClientFactory\n * @param {object} dyno - a dyno client\n * @param {string} dataset - the name of the dataset\n * @returns {metadata} a metadata client\n */\nmodule.exports = function(dyno, dataset) {\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NULL': [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } },\n            opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = [ 'west', 'south', 'east', 'north' ];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {'GT': bound } : {'LT': bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NOT_NULL' : [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from),\n            toInfo = metadata.getFeatureInfo(to),\n            bounds = toInfo.bounds,\n            size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n};"
    },
    "name": "MetadataClientFactory",
    "params": [
      {
        "title": "param",
        "description": "a dyno client",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "dyno"
      },
      {
        "title": "param",
        "description": "the name of the dataset",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "dataset"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "a metadata client",
        "type": {
          "type": "NameExpression",
          "name": "metadata"
        }
      }
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "MetadataClientFactory"
    ]
  },
  {
    "description": "",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "PaginationOptions"
      },
      {
        "title": "type",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "object"
        }
      },
      {
        "title": "property",
        "description": "start reading features past the provided id",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "start"
      },
      {
        "title": "property",
        "description": "maximum number of features to return",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "maxFeatures"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 51,
          "column": 0
        },
        "end": {
          "line": 380,
          "column": 2
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/index.js",
      "code": "var through = require('through2');\nvar _ = require('lodash');\nvar geojsonStream = require('geojson-stream');\nvar geojsonNormalize = require('geojson-normalize');\nvar concat = require('concat-stream');\nvar coverOpts = require('./lib/coveropts');\nvar Metadata = require('./lib/metadata');\nvar uniq = require('uniq');\nvar geobuf = require('geobuf');\nvar log = require('debug')('cardboard');\nvar queue = require('queue-async');\nvar Dyno = require('dyno');\nvar AWS = require('aws-sdk');\nvar extent = require('geojson-extent');\nvar cuid = require('cuid');\nvar url = require('url');\nvar tilebelt = require('tilebelt');\n\nvar MAX_GEOMETRY_SIZE = 1024*10;  //10KB\nvar LARGE_INDEX_DISTANCE = 50; //bbox more then 100 miles corner to corner.\n\n// /**\n//  * Handle the response from inserting or updating a feature\n//  * @callback cardboard~putCallback\n//  * @param {object} err - an error object, set to null if no error occurred\n//  * @param {object} feature - a stored version of the GeoJSON feature that was inserted or updated\n//  */\n\n/**\n * @name PaginationOptions\n * @type {object}\n * @property {string} start - start reading features past the provided id\n * @property {number} maxFeatures - maximum number of features to return\n */\n\n/**\n * @name CardboardClientConfiguration\n * @type {object}\n * @property {string} table - the name of a DynamoDB table to connect to\n * @property {string} region - the AWS region containing the DynamoDB table\n * @property {string} bucket - the name of an S3 bucket to use\n * @property {string} prefix - the name of a folder within the indicated S3 bucket\n */\n\n/**\n * Creates a cardboard client\n * @name CardboardClientFactory\n * @param {CardboardClientConfiguration} config - a configuration object\n * @returns {cardboard} a cardboard client\n */\nmodule.exports = function(config) {\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n};\n\nfunction indexLevel(feature) {\n    var bbox = extent(feature);\n    var sw = point(bbox[0], bbox[1]);\n    var ne = point(bbox[2], bbox[3]);\n    var dist = distance(sw, ne, 'miles');\n    return dist >= LARGE_INDEX_DISTANCE ? 0 : 1;\n}\n\nfunction truncateNum(num, digits) {\n    digits = digits || 6;\n    var exp = Math.pow(10, digits);\n    return Math.round(exp * num) / exp;\n}"
    },
    "name": "PaginationOptions",
    "properties": [
      {
        "title": "property",
        "description": "start reading features past the provided id",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "start"
      },
      {
        "title": "property",
        "description": "maximum number of features to return",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "maxFeatures"
      }
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "PaginationOptions"
    ]
  },
  {
    "description": "Gain access to utils",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "UtilsFactory"
      },
      {
        "title": "param",
        "description": "cardboard configuration object",
        "type": {
          "type": "NameExpression",
          "name": "CardboardClientConfiguration"
        },
        "name": "config"
      },
      {
        "title": "returns",
        "description": "module containing utility functions",
        "type": {
          "type": "NameExpression",
          "name": "utils"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 16,
          "column": 0
        },
        "end": {
          "line": 101,
          "column": 2
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/lib/utils.js",
      "code": "var queue = require('queue-async');\nvar geobuf = require('geobuf');\nvar url = require('url');\nvar geojsonNormalize = require('geojson-normalize');\nvar _ = require('lodash');\nvar cuid = require('cuid');\nvar Metadata = require('./metadata');\nvar tilebelt = require('tilebelt');\n\n/**\n * Gain access to utils\n * @name UtilsFactory\n * @param {CardboardClientConfiguration} config - cardboard configuration object\n * @returns {utils} module containing utility functions\n */\nmodule.exports = function(config) {\n    /**\n     * A module containing internal utility functions\n     */\n    var utils = {};\n\n    /**\n     * Convert a set of backend records into a GeoJSON features\n     * @param {object[]} dynamoRecords - an array of items returned from DynamoDB in object format\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.resolveFeatures = function(dynamoRecords, callback) {\n        var q = queue(100); // Concurrency of S3 requests\n\n        dynamoRecords.forEach(function(dynamoRecord) {\n            var val = dynamoRecord.val;\n            var uri = url.parse(dynamoRecord.s3url);\n\n            q.defer(function(next) {\n                if (val) return next(null, geobuf.geobufToFeature(val));\n\n                config.s3.getObject({\n                    Bucket: uri.host,\n                    Key: uri.pathname.substr(1)\n                }, function(err, data) {\n                    if (err) return next(err);\n                    next(null, geobuf.geobufToFeature(data.Body));\n                });\n            });\n        });\n\n        q.awaitAll(function(err, results) {\n            if (err) return callback(err);\n            callback(null, utils.featureCollection(results));\n        });\n    };\n\n    /**\n     * Wraps an array of GeoJSON features in a FeatureCollection\n     * @private\n     * @param {object[]} records - an array of GeoJSON features\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.featureCollection = function(records, callback) {\n        return geojsonNormalize({ type: 'FeatureCollection', features: records });\n    };\n\n    /**\n     * Converts a single GeoJSON feature into backend format\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset the feature belongs to\n     * @returns {object[]} an array: The first element is a DynamoDB record suitable for inserting via dyno.putItem, the second are parameters suitable for uploading via s3.putObject.\n     */\n    utils.toDatabaseRecord = function(feature, dataset) {\n        var f = feature.hasOwnProperty('id') ? _.clone(feature) : _.extend({ id: cuid() }, feature);\n        var primary = f.id;\n\n        if (!f.geometry || !f.geometry.coordinates)\n            throw new Error('Unlocated features can not be stored.');\n\n        var info = Metadata(config.dyno, dataset).getFeatureInfo(f);\n        var buf = geobuf.featureToGeobuf(f).toBuffer();\n        var tile = tilebelt.bboxToTile([info.west, info.south, info.east, info.north]);\n        var cell = tilebelt.tileToQuadkey(tile);\n        var useS3 = buf.length >= config.MAX_GEOMETRY_SIZE;\n        var s3Key = [config.prefix, dataset, primary, +new Date()].join('/');\n        var s3Params = { Bucket: config.bucket, Key: s3Key, Body: buf };\n\n        var item = {\n            dataset: dataset,\n            id: 'id!' + primary,\n            cell: 'cell!' + cell,\n            size: info.size,\n            west: truncateNum(info.west),\n            south: truncateNum(info.south),\n            east: truncateNum(info.east),\n            north: truncateNum(info.north),\n            s3url: ['s3:/', config.bucket, s3Key].join('/')\n        };\n\n        if (!useS3) item.val = buf;\n        return [item, s3Params];\n    };\n\n    return utils;\n};\n\nfunction truncateNum(num) {\n    return Math.round(Math.pow(10, 6) * num) / Math.pow(10, 6);\n}"
    },
    "name": "UtilsFactory",
    "params": [
      {
        "title": "param",
        "description": "cardboard configuration object",
        "type": {
          "type": "NameExpression",
          "name": "CardboardClientConfiguration"
        },
        "name": "config"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "module containing utility functions",
        "type": {
          "type": "NameExpression",
          "name": "utils"
        }
      }
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "UtilsFactory"
    ]
  },
  {
    "description": "A client configured to interact with a backend cardboard database",
    "tags": [
      {
        "title": "name",
        "name": "cardboard"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 69,
          "column": 4
        },
        "end": {
          "line": 74,
          "column": 6
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/index.js",
      "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
    },
    "name": "cardboard",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "A module for batch requests",
          "tags": [
            {
              "title": "name",
              "name": "batch"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 73,
                "column": 8
              },
              "end": {
                "line": 73,
                "column": 45
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    }"
          },
          "name": "batch",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": [
              {
                "description": "Insert or update a set of GeoJSON features",
                "tags": [
                  {
                    "title": "param",
                    "description": "a GeoJSON FeatureCollection containing features to insert and/or update",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "collection"
                  },
                  {
                    "title": "param",
                    "description": "the name of the dataset that these features belongs to",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "dataset"
                  },
                  {
                    "title": "param",
                    "description": "the callback function to handle the response",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "callback"
                  },
                  {
                    "title": "name",
                    "name": "put"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  },
                  {
                    "title": "memberof",
                    "description": "batch"
                  },
                  {
                    "title": "static"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 21,
                      "column": 4
                    },
                    "end": {
                      "line": 48,
                      "column": 6
                    }
                  },
                  "file": "/Users/r/gh/mapbox/cardboard/lib/batch.js",
                  "code": "{\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    var utils = require('./utils')(config);\n\n    var batch = {};\n\n    /**\n     * Insert or update a set of GeoJSON features\n     * @param {object} collection - a GeoJSON FeatureCollection containing features to insert and/or update\n     * @param {string} dataset - the name of the dataset that these features belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.put = function(collection, dataset, callback) {\n        var records = [];\n        var geobufs = [];\n        var s3objects = [];\n\n        var encoded;\n        var q = queue(150);\n\n        for (var i = 0; i < collection.features.length; i++) {\n            try { encoded = utils.toDatabaseRecord(collection.features[i], dataset); }\n            catch (err) { return callback(err); }\n\n            records.push(encoded[0]);\n            geobufs.push(encoded[1].Body);\n            q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        }\n\n        q.awaitAll(function(err) {\n            if (err) return callback(err);\n            config.dyno.putItems(records, function(err, items) {\n                if (err) return callback(err);\n\n                var features = geobufs.map(geobuf.geobufToFeature.bind(geobuf));\n\n                callback(null, { type: 'FeatureCollection', features: features });\n            });\n        });\n    };\n\n    /**\n     * Remove a set of features\n     * @param {string[]} ids - an array of feature ids to remove\n     * @param {string} dataset - the name of the dataset that these features belong to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.remove = function(ids, dataset, callback) {\n        var keys = ids.map(function(id) {\n            return { dataset: dataset, id: 'id!' + id };\n        });\n\n        config.dyno.deleteItems(keys, function(err) {\n            callback(err);\n        });\n    };\n\n    return batch;\n}"
                },
                "params": [
                  {
                    "title": "param",
                    "description": "a GeoJSON FeatureCollection containing features to insert and/or update",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "collection"
                  },
                  {
                    "title": "param",
                    "description": "the name of the dataset that these features belongs to",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "dataset"
                  },
                  {
                    "title": "param",
                    "description": "the callback function to handle the response",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "callback"
                  }
                ],
                "name": "put",
                "kind": "function",
                "memberof": "batch",
                "scope": "static",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "cardboard",
                  "batch",
                  "put"
                ]
              },
              {
                "description": "Remove a set of features",
                "tags": [
                  {
                    "title": "param",
                    "description": "an array of feature ids to remove",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "string"
                        }
                      ]
                    },
                    "name": "ids"
                  },
                  {
                    "title": "param",
                    "description": "the name of the dataset that these features belong to",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "dataset"
                  },
                  {
                    "title": "param",
                    "description": "the callback function to handle the response",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "callback"
                  },
                  {
                    "title": "name",
                    "name": "remove"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  },
                  {
                    "title": "memberof",
                    "description": "batch"
                  },
                  {
                    "title": "static"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 56,
                      "column": 4
                    },
                    "end": {
                      "line": 64,
                      "column": 6
                    }
                  },
                  "file": "/Users/r/gh/mapbox/cardboard/lib/batch.js",
                  "code": "{\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    var utils = require('./utils')(config);\n\n    var batch = {};\n\n    /**\n     * Insert or update a set of GeoJSON features\n     * @param {object} collection - a GeoJSON FeatureCollection containing features to insert and/or update\n     * @param {string} dataset - the name of the dataset that these features belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.put = function(collection, dataset, callback) {\n        var records = [];\n        var geobufs = [];\n        var s3objects = [];\n\n        var encoded;\n        var q = queue(150);\n\n        for (var i = 0; i < collection.features.length; i++) {\n            try { encoded = utils.toDatabaseRecord(collection.features[i], dataset); }\n            catch (err) { return callback(err); }\n\n            records.push(encoded[0]);\n            geobufs.push(encoded[1].Body);\n            q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        }\n\n        q.awaitAll(function(err) {\n            if (err) return callback(err);\n            config.dyno.putItems(records, function(err, items) {\n                if (err) return callback(err);\n\n                var features = geobufs.map(geobuf.geobufToFeature.bind(geobuf));\n\n                callback(null, { type: 'FeatureCollection', features: features });\n            });\n        });\n    };\n\n    /**\n     * Remove a set of features\n     * @param {string[]} ids - an array of feature ids to remove\n     * @param {string} dataset - the name of the dataset that these features belong to\n     * @param {function} callback - the callback function to handle the response\n     */\n    batch.remove = function(ids, dataset, callback) {\n        var keys = ids.map(function(id) {\n            return { dataset: dataset, id: 'id!' + id };\n        });\n\n        config.dyno.deleteItems(keys, function(err) {\n            callback(err);\n        });\n    };\n\n    return batch;\n}"
                },
                "params": [
                  {
                    "title": "param",
                    "description": "an array of feature ids to remove",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "string"
                        }
                      ]
                    },
                    "name": "ids"
                  },
                  {
                    "title": "param",
                    "description": "the name of the dataset that these features belong to",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "dataset"
                  },
                  {
                    "title": "param",
                    "description": "the callback function to handle the response",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "callback"
                  }
                ],
                "name": "remove",
                "kind": "function",
                "memberof": "batch",
                "scope": "static",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "cardboard",
                  "batch",
                  "remove"
                ]
              }
            ]
          },
          "path": [
            "cardboard",
            "batch"
          ]
        },
        {
          "description": "Find GeoJSON features that intersect a bounding box",
          "tags": [
            {
              "title": "param",
              "description": "the bounding box as `[west, south, east, north]`",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bbox"
            },
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "bboxQuery"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 236,
                "column": 4
              },
              "end": {
                "line": 358,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "the bounding box as `[west, south, east, north]`",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bbox"
            },
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "bboxQuery",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "bboxQuery"
          ]
        },
        {
          "description": "Calculate metadata about a dataset",
          "tags": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "calculateDatasetInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 226,
                "column": 4
              },
              "end": {
                "line": 228,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "calculateDatasetInfo",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "calculateDatasetInfo"
          ]
        },
        {
          "description": "Create a DynamoDB table with Cardboard's schema",
          "tags": [
            {
              "title": "param",
              "description": "the name of the table to create, if not provided, defaults to the tablename defined in client configuration.",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "string"
                }
              },
              "name": "tableName"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "createTable"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 137,
                "column": 4
              },
              "end": {
                "line": 141,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the table to create, if not provided, defaults to the tablename defined in client configuration.",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "string"
                }
              },
              "name": "tableName"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "createTable",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "createTable"
          ]
        },
        {
          "description": "Remove a single GeoJSON feature",
          "tags": [
            {
              "title": "param",
              "description": "the id for a feature",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "primary"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "del"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 103,
                "column": 4
              },
              "end": {
                "line": 111,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "the id for a feature",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "primary"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "del",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "del"
          ]
        },
        {
          "description": "Retreive a single GeoJSON feature",
          "tags": [
            {
              "title": "param",
              "description": "the id for a feature",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "primary"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "get"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 119,
                "column": 4
              },
              "end": {
                "line": 130,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "the id for a feature",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "primary"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "get",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "get"
          ]
        },
        {
          "description": "Get cached metadata about a dataset",
          "tags": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getDatasetInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 217,
                "column": 4
              },
              "end": {
                "line": 219,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getDatasetInfo",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "getDatasetInfo"
          ]
        },
        {
          "description": "List the GeoJSON features that belong to a particular dataset",
          "tags": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "pagination options",
              "type": {
                "type": "NameExpression",
                "name": "PaginationOptions"
              },
              "name": "pageOptions"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "list"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 162,
                "column": 4
              },
              "end": {
                "line": 182,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "the name of the dataset",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "pagination options",
              "type": {
                "type": "NameExpression",
                "name": "PaginationOptions"
              },
              "name": "pageOptions"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "list",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "list"
          ]
        },
        {
          "description": "List datasets available in this database",
          "tags": [
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "listDatasets"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 200,
                "column": 4
              },
              "end": {
                "line": 210,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "listDatasets",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "listDatasets"
          ]
        },
        {
          "description": "Insert or update a single GeoJSON feature",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "put"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "cardboard"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 82,
                "column": 4
              },
              "end": {
                "line": 95,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/index.js",
            "code": "{\n    config = config || {};\n    config.MAX_GEOMETRY_SIZE = config.MAX_GEOMETRY_SIZE || MAX_GEOMETRY_SIZE;\n\n    // Allow caller to pass in aws-sdk clients\n    if (!config.s3) config.s3 = new AWS.S3(config);\n    if (!config.dyno) config.dyno = Dyno(config);\n\n    if (!config.table && !config.dyno) throw new Error('No table set');\n    if (!config.region && !config.dyno) throw new Error('No region set');\n    if (!config.bucket) throw new Error('No bucket set');\n    if (!config.prefix) throw new Error('No s3 prefix set');\n\n    var utils = require('./lib/utils')(config);\n\n    /**\n     * A client configured to interact with a backend cardboard database\n     */\n    var cardboard = {\n        /**\n         * A module for batch requests\n         */\n        batch: require('./lib/batch')(config)\n    };\n\n    /**\n     * Insert or update a single GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.put = function(feature, dataset, callback) {\n        var encoded;\n        try { encoded = utils.toDatabaseRecord(feature, dataset); }\n        catch (err) { return callback(err); }\n\n        var q = queue(1);\n        q.defer(config.s3.putObject.bind(config.s3), encoded[1]);\n        q.defer(config.dyno.putItem, encoded[0]);\n        q.await(function(err) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.id = encoded[0].id.split('!')[1];\n            callback(err, result);\n        });\n    };\n\n    /**\n     * Remove a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.del = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.deleteItem(key, { expected: { id: 'NOT_NULL'} }, function(err, res) {\n            if (err && err.code === 'ConditionalCheckFailedException') return callback(new Error('Feature does not exist'));\n            if (err) return callback(err, true);\n            else callback();\n        });\n    };\n\n    /**\n     * Retreive a single GeoJSON feature\n     * @param {string} primary - the id for a feature\n     * @param {string} dataset - the name of the dataset that this feature belongs to\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.get = function(primary, dataset, callback) {\n        var key = { dataset: dataset, id: 'id!' + primary };\n\n        config.dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            if (!item) return callback(new Error('Feature ' + primary + ' does not exist'));\n            utils.resolveFeatures([item], function(err, features) {\n                if (err) return callback(err);\n                callback(null, features.features[0]);\n            });\n        });\n    };\n\n    /**\n     * Create a DynamoDB table with Cardboard's schema\n     * @param {string} [tableName] - the name of the table to create, if not provided, defaults to the tablename defined in client configuration.\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.createTable = function(tableName, callback) {\n        var table = require('./lib/table.json');\n        table.TableName = tableName;\n        config.dyno.createTable(table, callback);\n    };\n\n    cardboard.delDataset = function(dataset, callback) {\n        cardboard.listIds(dataset, function(err, res) {\n            var keys = res.map(function(id){\n                return { dataset: dataset, id: 'id!'+id };\n            });\n            keys.push({ dataset: dataset, id: 'metadata!'+dataset });\n\n            config.dyno.deleteItems(keys, function(err, res) {\n                callback(err);\n            });\n        });\n    };\n\n    /**\n     * List the GeoJSON features that belong to a particular dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {PaginationOptions} pageOptions - pagination options\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.list = function(dataset, pageOptions, callback) {\n        var opts = {};\n\n        if (typeof pageOptions === 'function') {\n            callback = pageOptions;\n            opts.pages = 0;\n            pageOptions = {};\n        }\n\n        if (pageOptions.start) opts.start = pageOptions.start;\n        if (pageOptions.maxFeatures) opts.limit = pageOptions.maxFeatures;\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } };\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            utils.resolveFeatures(items, function(err, features) {\n                if (err) return callback(err);\n                callback(null, features);\n            });\n        });\n    };\n\n    cardboard.listIds = function(dataset, callback) {\n        var query = { dataset: { EQ: dataset }, id: {BEGINS_WITH: 'id!'} },\n            opts = { attributes: ['id'], pages: 0 };\n\n        config.dyno.query(query, opts, function(err, items) {\n            if (err) return callback(err);\n            callback(err, items.map(function(_) {\n                return _.id.split('!')[1];\n            }));\n        });\n    };\n\n    /**\n     * List datasets available in this database\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.listDatasets = function(callback) {\n        var opts = { attributes: ['dataset'], pages:0 };\n\n        config.dyno.scan(opts, function(err, items) {\n            if (err) return callback(err);\n            var datasets = _.uniq(items.map(function(item){\n                return item.dataset;\n            }));\n            callback(err, datasets);\n        });\n    };\n\n    /**\n     * Get cached metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.getDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).getInfo(callback);\n    };\n\n    /**\n     * Calculate metadata about a dataset\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.calculateDatasetInfo = function(dataset, callback) {\n        Metadata(config.dyno, dataset).calculateInfo(callback);\n    };\n\n    /**\n     * Find GeoJSON features that intersect a bounding box\n     * @param {number[]} bbox - the bounding box as `[west, south, east, north]`\n     * @param {string} dataset - the name of the dataset\n     * @param {function} callback - the callback function to handle the response\n     */\n    cardboard.bboxQuery = function(bbox, dataset, callback) {\n        var q = queue(100);\n\n        var bboxes = [bbox];\n        var epsilon = 1E-8;\n\n        // If a query crosses the (W) antimeridian/equator, we split it\n        // into separate queries to reduce overall throughput.\n        if (bbox[0] <= -180 && bbox[2] >= -180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -180 - epsilon, bbox[3]]);\n                memo.push([-180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // Likewise, if a query crosses the (E) antimeridian/equator,\n        // we split it.\n        else if (bbox[0] <= 180 && bbox[2] >= 180) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], 180 - epsilon, bbox[3]]);\n                memo.push([180 + epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        // If a query crosses the equator/prime meridian, we split it.\n        else if (bbox[0] <= 0 && bbox[2] >= 0) {\n            bboxes = bboxes.reduce(function(memo, bbox) {\n                memo.push([bbox[0], bbox[1], -epsilon, bbox[3]]);\n                memo.push([epsilon, bbox[1], bbox[2], bbox[3]]);\n                return memo;\n            }, []);\n            if (bbox[1] <= 0 && bbox[3] >= 0) {\n                bboxes = bboxes.reduce(function(memo, bbox) {\n                    memo.push([bbox[0], bbox[1], bbox[2], -epsilon]);\n                    memo.push([bbox[0], epsilon, bbox[2], bbox[3]]);\n                    return memo;\n                }, []);\n            }\n        }\n\n        var tiles = bboxes.map(function(bbox) {\n            return tilebelt.bboxToTile(bbox);\n        });\n\n        // Deduplicate subquery tiles.\n        uniq(tiles, function(a, b) {\n                return !tilebelt.tilesEqual(a, b);\n            });\n\n        if (tiles.length > 1) {\n            // Filter out the z0 tile -- we'll always search it eventually.\n            tiles = _.filter(tiles, function(item) {\n                return item[2] !== 0;\n                });\n        }\n\n        tiles.forEach(function(tile) {\n            var tileKey = tilebelt.tileToQuadkey(tile);\n\n            // First find features indexed in children of this tile\n            var query = {\n                cell: { 'BEGINS_WITH': 'cell!' + tileKey },\n                dataset: { 'EQ': dataset }\n            };\n\n            var options = {\n                pages: 0,\n                index: 'cell',\n                filter : {\n                    west: { 'LE': bbox[2] },\n                    east: { 'GE': bbox[0] },\n                    north: { 'GE': bbox[1] },\n                    south: { 'LE': bbox[3] }\n                }\n            };\n            q.defer(config.dyno.query, query, options);\n\n            // Travel up the parent tiles, finding features indexed in each\n            var parentTileKey = tileKey.slice(0, -1);\n\n            while (tileKey.length > 0) {\n                query.cell = { 'EQ': 'cell!' + parentTileKey };\n                q.defer(config.dyno.query, query, options);\n                if (parentTileKey.length === 0) {\n                    break;\n                }\n                parentTileKey = parentTileKey.slice(0, -1);\n            }\n        });\n\n        q.awaitAll(function(err, items) {\n            if (err) return callback(err);\n\n            items = _.flatten(items);\n\n            // Reduce the response's records to the set of\n            // records with unique ids.\n            uniq(items, function(a, b) {\n                return a.id !== b.id;\n            });\n\n            utils.resolveFeatures(items, function(err, data) {\n                if (err) return callback(err);\n                callback(err, data);\n            });\n        });\n    };\n\n    cardboard.dump = function(cb) {\n        return config.dyno.scan(cb);\n    };\n\n    cardboard.export = function(_) {\n        return config.dyno.scan()\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                var output = this.push.bind(this);\n                if (data.id.indexOf('id!') === 0) {\n                    return utils.resolveFeatures([data], function(err, features) {\n                        output(features.features[0]);\n                        cb();\n                    });\n                }\n                cb();\n            }))\n            .pipe(geojsonStream.stringify());\n    };\n\n    return cardboard;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "the name of the dataset that this feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "param",
              "description": "the callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "put",
          "kind": "function",
          "memberof": "cardboard",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cardboard",
            "put"
          ]
        }
      ]
    },
    "path": [
      "cardboard"
    ]
  },
  {
    "description": "A client for interacting with the metadata for a dataset",
    "tags": [
      {
        "title": "name",
        "name": "metadata"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 17,
          "column": 4
        },
        "end": {
          "line": 17,
          "column": 22
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
      "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NULL': [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } },\n            opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = [ 'west', 'south', 'east', 'north' ];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {'GT': bound } : {'LT': bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NOT_NULL' : [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from),\n            toInfo = metadata.getFeatureInfo(to),\n            bounds = toInfo.bounds,\n            size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}"
    },
    "name": "metadata",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature being added to the dataset",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "addFeature"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 173,
                "column": 4
              },
              "end": {
                "line": 184,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NULL': [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } },\n            opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = [ 'west', 'south', 'east', 'north' ];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {'GT': bound } : {'LT': bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NOT_NULL' : [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from),\n            toInfo = metadata.getFeatureInfo(to),\n            bounds = toInfo.bounds,\n            size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature being added to the dataset",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "addFeature",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "addFeature"
          ]
        },
        {
          "description": "Find all features in a dataset and bring metadata record up-to-date",
          "tags": [
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "calculateInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 94,
                "column": 4
              },
              "end": {
                "line": 127,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NULL': [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } },\n            opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = [ 'west', 'south', 'east', 'north' ];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {'GT': bound } : {'LT': bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NOT_NULL' : [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from),\n            toInfo = metadata.getFeatureInfo(to),\n            bounds = toInfo.bounds,\n            size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "calculateInfo",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "calculateInfo"
          ]
        },
        {
          "description": "Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature to remove from the dataset",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "deleteFeature"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 209,
                "column": 4
              },
              "end": {
                "line": 215,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NULL': [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } },\n            opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = [ 'west', 'south', 'east', 'north' ];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {'GT': bound } : {'LT': bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NOT_NULL' : [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from),\n            toInfo = metadata.getFeatureInfo(to),\n            bounds = toInfo.bounds,\n            size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature to remove from the dataset",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "deleteFeature",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "deleteFeature"
          ]
        },
        {
          "description": "Return the details for a given GeoJSON feature",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "returns",
              "description": "an object describing the feature's size and extent",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "name",
              "name": "getFeatureInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 55,
                "column": 4
              },
              "end": {
                "line": 65,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NULL': [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } },\n            opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = [ 'west', 'south', 'east', 'north' ];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {'GT': bound } : {'LT': bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NOT_NULL' : [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from),\n            toInfo = metadata.getFeatureInfo(to),\n            bounds = toInfo.bounds,\n            size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "an object describing the feature's size and extent",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "name": "getFeatureInfo",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "getFeatureInfo"
          ]
        },
        {
          "description": "Return dataset metadata or an empty object",
          "tags": [
            {
              "title": "param",
              "description": "a callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 42,
                "column": 4
              },
              "end": {
                "line": 48,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NULL': [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } },\n            opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = [ 'west', 'south', 'east', 'north' ];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {'GT': bound } : {'LT': bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NOT_NULL' : [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from),\n            toInfo = metadata.getFeatureInfo(to),\n            bounds = toInfo.bounds,\n            size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "a callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getInfo",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "getInfo"
          ]
        },
        {
          "description": "Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature representing the state of the feature *before* the update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "from"
            },
            {
              "title": "param",
              "description": "a GeoJSON feature representing the state of the feature *after* the update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "to"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "updateFeature"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "metadata"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 192,
                "column": 4
              },
              "end": {
                "line": 202,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/metadata.js",
            "code": "{\n\n    /**\n     * A client for interacting with the metadata for a dataset\n     */\n    var metadata = {};\n    var recordId = metadata.recordId = 'metadata!' + dataset;\n    var key = metadata.key = { id: recordId, dataset: dataset };\n\n    /**\n     * Helper routine for performing conditional updates. Ignores ConditionalCheckFailedExceptions, but returns true/false to indicate whether an update was performed\n     * @private\n     * @param {object} item - a dyno object\n     * @param {object} opts - an object defining the conditional expression\n     * @param {function} cb - a callback function to handle the response\n     */\n    function conditionalUpdate(item, opts, cb) {\n        dyno.updateItem(key, item, opts, function(err) {\n            if (err && err.code === 'ConditionalCheckFailedException')\n                return cb(null, false);\n            else if (err)\n                return cb(err, false);\n            cb(null, true);\n        });\n    }\n\n    /**\n     * Return dataset metadata or an empty object\n     * @param {function} callback - a callback function to handle the response\n     */\n    metadata.getInfo = function(callback) {\n        dyno.getItem(key, function(err, item) {\n            if (err) return callback(err);\n            info = item || {};\n            callback(null, info);\n        });\n    };\n\n    /**\n     * Return the details for a given GeoJSON feature\n     * @param {object} feature - a GeoJSON feature\n     * @returns {object} an object describing the feature's size and extent\n     */\n    metadata.getFeatureInfo = function(feature) {\n        var bounds = extent(feature);\n        return {\n            size: Buffer.byteLength(JSON.stringify(feature)),\n            bounds: bounds,\n            west: bounds[0],\n            south: bounds[1],\n            east: bounds[2],\n            north: bounds[3]\n        };\n    };\n\n    /**\n     * Create and stores a metadata record with default values if no record exists. Returns true/false to indicate whether a record was created.\n     * @private\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.defaultInfo = function(callback) {\n        var info = {};\n        info.put = {\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NULL': [] };\n\n        conditionalUpdate(info, opts, callback);\n    };\n\n    /**\n     * Find all features in a dataset and bring metadata record up-to-date\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.calculateInfo = function(callback) {\n        var info = {\n            dataset: dataset,\n            id: recordId,\n            west: 180,\n            south: 90,\n            east: -180,\n            north: -90,\n            count: 0,\n            size: 0,\n            updated: +new Date()\n        };\n\n        var query = { dataset: { EQ: dataset }, id: { BEGINS_WITH: 'id!' } },\n            opts = { pages: 0 };\n\n        dyno.query(query, opts)\n            .on('error', callback)\n            .pipe(through({ objectMode: true }, function(data, enc, cb) {\n                info.count++;\n                info.size = info.size + data.size;\n                info.west = info.west > data.west ? data.west : info.west;\n                info.south = info.south > data.south ? data.south : info.south;\n                info.east = info.east < data.east ? data.east : info.east;\n                info.north = info.north < data.north ? data.north : info.north;\n                cb();\n            }))\n            .on('error', callback)\n            .on('finish', function() {\n                dyno.putItem(info, function(err) {\n                    callback(err, info);\n                });\n            });\n    };\n\n    /**\n     * Adjust the bounds in an existing metadata record. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {number[]} bounds - bounds to add to the existing bounds for the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustBounds = function(bounds, callback) {\n        var q = queue();\n        var labels = [ 'west', 'south', 'east', 'north' ];\n\n        bounds.forEach(function(bound, i) {\n            var item = { put: {} };\n            item.put[labels[i]] = bound;\n            item.put.updated = +new Date();\n\n            var opts = { expected: {} };\n            opts.expected[labels[i]] =  i < 2 ? {'GT': bound } : {'LT': bound };\n            q.defer(conditionalUpdate, item, opts);\n        });\n\n        q.awaitAll(callback);\n    };\n\n    /**\n     * Increment/decrement the specified properties. This operation **will not** create a metadata record if one does not exist.\n     * @private\n     * @param {object} properties - an object describing the properties in increase or decrease\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.adjustProperties = function(properties, callback) {\n        var item = { add: properties, put: {} };\n        item.put.updated = +new Date();\n\n        var opts = { expected: {} };\n        opts.expected.id = { 'NOT_NULL' : [] };\n\n        conditionalUpdate(item, opts, callback);\n    };\n\n    /**\n     * Given a GeoJSON feature, perform all required metadata updates. This operation **will** create a metadata record if one does not exist.\n     * @param {object} feature - a GeoJSON feature being added to the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.addFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        metadata.defaultInfo(function(err) {\n            if (err) return callback(err);\n\n            queue()\n                .defer(metadata.adjustProperties, { count: 1, size: info.size })\n                .defer(metadata.adjustBounds, info.bounds)\n                .awaitAll(callback);\n        });\n    };\n\n    /**\n     * Given before and after states of a GeoJSON feature, perform all required metadata adjustments. This operation **will not** create a metadata record if one does not exist.\n     * @param {object} from - a GeoJSON feature representing the state of the feature *before* the update\n     * @param {object} to - a GeoJSON feature representing the state of the feature *after* the update\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.updateFeature = function(from, to, callback) {\n        var fromInfo = metadata.getFeatureInfo(from),\n            toInfo = metadata.getFeatureInfo(to),\n            bounds = toInfo.bounds,\n            size = toInfo.size - fromInfo.size;\n\n        queue()\n            .defer(metadata.adjustProperties, { size: size })\n            .defer(metadata.adjustBounds, bounds)\n            .awaitAll(callback);\n    };\n\n    /**\n     * Given a GeoJSON feature to remove, perform all required metadata updates. This operation **will not** create a metadata record if one does not exist. This operation **will not** shrink metadata bounds.\n     * @param {object} feature - a GeoJSON feature to remove from the dataset\n     * @param {function} callback - a function to handle the response\n     */\n    metadata.deleteFeature = function(feature, callback) {\n        var info = metadata.getFeatureInfo(feature);\n\n        queue()\n            .defer(metadata.adjustProperties, { count: -1, size: -info.size })\n            .awaitAll(callback);\n    };\n\n    return metadata;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature representing the state of the feature *before* the update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "from"
            },
            {
              "title": "param",
              "description": "a GeoJSON feature representing the state of the feature *after* the update",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "to"
            },
            {
              "title": "param",
              "description": "a function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "updateFeature",
          "kind": "function",
          "memberof": "metadata",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "metadata",
            "updateFeature"
          ]
        }
      ]
    },
    "path": [
      "metadata"
    ]
  },
  {
    "description": "A module containing internal utility functions",
    "tags": [
      {
        "title": "name",
        "name": "utils"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 20,
          "column": 4
        },
        "end": {
          "line": 20,
          "column": 19
        }
      },
      "file": "/Users/r/gh/mapbox/cardboard/lib/utils.js",
      "code": "{\n    /**\n     * A module containing internal utility functions\n     */\n    var utils = {};\n\n    /**\n     * Convert a set of backend records into a GeoJSON features\n     * @param {object[]} dynamoRecords - an array of items returned from DynamoDB in object format\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.resolveFeatures = function(dynamoRecords, callback) {\n        var q = queue(100); // Concurrency of S3 requests\n\n        dynamoRecords.forEach(function(dynamoRecord) {\n            var val = dynamoRecord.val;\n            var uri = url.parse(dynamoRecord.s3url);\n\n            q.defer(function(next) {\n                if (val) return next(null, geobuf.geobufToFeature(val));\n\n                config.s3.getObject({\n                    Bucket: uri.host,\n                    Key: uri.pathname.substr(1)\n                }, function(err, data) {\n                    if (err) return next(err);\n                    next(null, geobuf.geobufToFeature(data.Body));\n                });\n            });\n        });\n\n        q.awaitAll(function(err, results) {\n            if (err) return callback(err);\n            callback(null, utils.featureCollection(results));\n        });\n    };\n\n    /**\n     * Wraps an array of GeoJSON features in a FeatureCollection\n     * @private\n     * @param {object[]} records - an array of GeoJSON features\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.featureCollection = function(records, callback) {\n        return geojsonNormalize({ type: 'FeatureCollection', features: records });\n    };\n\n    /**\n     * Converts a single GeoJSON feature into backend format\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset the feature belongs to\n     * @returns {object[]} an array: The first element is a DynamoDB record suitable for inserting via dyno.putItem, the second are parameters suitable for uploading via s3.putObject.\n     */\n    utils.toDatabaseRecord = function(feature, dataset) {\n        var f = feature.hasOwnProperty('id') ? _.clone(feature) : _.extend({ id: cuid() }, feature);\n        var primary = f.id;\n\n        if (!f.geometry || !f.geometry.coordinates)\n            throw new Error('Unlocated features can not be stored.');\n\n        var info = Metadata(config.dyno, dataset).getFeatureInfo(f);\n        var buf = geobuf.featureToGeobuf(f).toBuffer();\n        var tile = tilebelt.bboxToTile([info.west, info.south, info.east, info.north]);\n        var cell = tilebelt.tileToQuadkey(tile);\n        var useS3 = buf.length >= config.MAX_GEOMETRY_SIZE;\n        var s3Key = [config.prefix, dataset, primary, +new Date()].join('/');\n        var s3Params = { Bucket: config.bucket, Key: s3Key, Body: buf };\n\n        var item = {\n            dataset: dataset,\n            id: 'id!' + primary,\n            cell: 'cell!' + cell,\n            size: info.size,\n            west: truncateNum(info.west),\n            south: truncateNum(info.south),\n            east: truncateNum(info.east),\n            north: truncateNum(info.north),\n            s3url: ['s3:/', config.bucket, s3Key].join('/')\n        };\n\n        if (!useS3) item.val = buf;\n        return [item, s3Params];\n    };\n\n    return utils;\n}"
    },
    "name": "utils",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Convert a set of backend records into a GeoJSON features",
          "tags": [
            {
              "title": "param",
              "description": "an array of items returned from DynamoDB in object format",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "object"
                  }
                ]
              },
              "name": "dynamoRecords"
            },
            {
              "title": "param",
              "description": "a callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "resolveFeatures"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "utils"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 27,
                "column": 4
              },
              "end": {
                "line": 51,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/utils.js",
            "code": "{\n    /**\n     * A module containing internal utility functions\n     */\n    var utils = {};\n\n    /**\n     * Convert a set of backend records into a GeoJSON features\n     * @param {object[]} dynamoRecords - an array of items returned from DynamoDB in object format\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.resolveFeatures = function(dynamoRecords, callback) {\n        var q = queue(100); // Concurrency of S3 requests\n\n        dynamoRecords.forEach(function(dynamoRecord) {\n            var val = dynamoRecord.val;\n            var uri = url.parse(dynamoRecord.s3url);\n\n            q.defer(function(next) {\n                if (val) return next(null, geobuf.geobufToFeature(val));\n\n                config.s3.getObject({\n                    Bucket: uri.host,\n                    Key: uri.pathname.substr(1)\n                }, function(err, data) {\n                    if (err) return next(err);\n                    next(null, geobuf.geobufToFeature(data.Body));\n                });\n            });\n        });\n\n        q.awaitAll(function(err, results) {\n            if (err) return callback(err);\n            callback(null, utils.featureCollection(results));\n        });\n    };\n\n    /**\n     * Wraps an array of GeoJSON features in a FeatureCollection\n     * @private\n     * @param {object[]} records - an array of GeoJSON features\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.featureCollection = function(records, callback) {\n        return geojsonNormalize({ type: 'FeatureCollection', features: records });\n    };\n\n    /**\n     * Converts a single GeoJSON feature into backend format\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset the feature belongs to\n     * @returns {object[]} an array: The first element is a DynamoDB record suitable for inserting via dyno.putItem, the second are parameters suitable for uploading via s3.putObject.\n     */\n    utils.toDatabaseRecord = function(feature, dataset) {\n        var f = feature.hasOwnProperty('id') ? _.clone(feature) : _.extend({ id: cuid() }, feature);\n        var primary = f.id;\n\n        if (!f.geometry || !f.geometry.coordinates)\n            throw new Error('Unlocated features can not be stored.');\n\n        var info = Metadata(config.dyno, dataset).getFeatureInfo(f);\n        var buf = geobuf.featureToGeobuf(f).toBuffer();\n        var tile = tilebelt.bboxToTile([info.west, info.south, info.east, info.north]);\n        var cell = tilebelt.tileToQuadkey(tile);\n        var useS3 = buf.length >= config.MAX_GEOMETRY_SIZE;\n        var s3Key = [config.prefix, dataset, primary, +new Date()].join('/');\n        var s3Params = { Bucket: config.bucket, Key: s3Key, Body: buf };\n\n        var item = {\n            dataset: dataset,\n            id: 'id!' + primary,\n            cell: 'cell!' + cell,\n            size: info.size,\n            west: truncateNum(info.west),\n            south: truncateNum(info.south),\n            east: truncateNum(info.east),\n            north: truncateNum(info.north),\n            s3url: ['s3:/', config.bucket, s3Key].join('/')\n        };\n\n        if (!useS3) item.val = buf;\n        return [item, s3Params];\n    };\n\n    return utils;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "an array of items returned from DynamoDB in object format",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "object"
                  }
                ]
              },
              "name": "dynamoRecords"
            },
            {
              "title": "param",
              "description": "a callback function to handle the response",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "resolveFeatures",
          "kind": "function",
          "memberof": "utils",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "utils",
            "resolveFeatures"
          ]
        },
        {
          "description": "Converts a single GeoJSON feature into backend format",
          "tags": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "the name of the dataset the feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            },
            {
              "title": "returns",
              "description": "an array: The first element is a DynamoDB record suitable for inserting via dyno.putItem, the second are parameters suitable for uploading via s3.putObject.",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "object"
                  }
                ]
              }
            },
            {
              "title": "name",
              "name": "toDatabaseRecord"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "utils"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 69,
                "column": 4
              },
              "end": {
                "line": 98,
                "column": 6
              }
            },
            "file": "/Users/r/gh/mapbox/cardboard/lib/utils.js",
            "code": "{\n    /**\n     * A module containing internal utility functions\n     */\n    var utils = {};\n\n    /**\n     * Convert a set of backend records into a GeoJSON features\n     * @param {object[]} dynamoRecords - an array of items returned from DynamoDB in object format\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.resolveFeatures = function(dynamoRecords, callback) {\n        var q = queue(100); // Concurrency of S3 requests\n\n        dynamoRecords.forEach(function(dynamoRecord) {\n            var val = dynamoRecord.val;\n            var uri = url.parse(dynamoRecord.s3url);\n\n            q.defer(function(next) {\n                if (val) return next(null, geobuf.geobufToFeature(val));\n\n                config.s3.getObject({\n                    Bucket: uri.host,\n                    Key: uri.pathname.substr(1)\n                }, function(err, data) {\n                    if (err) return next(err);\n                    next(null, geobuf.geobufToFeature(data.Body));\n                });\n            });\n        });\n\n        q.awaitAll(function(err, results) {\n            if (err) return callback(err);\n            callback(null, utils.featureCollection(results));\n        });\n    };\n\n    /**\n     * Wraps an array of GeoJSON features in a FeatureCollection\n     * @private\n     * @param {object[]} records - an array of GeoJSON features\n     * @param {function} callback - a callback function to handle the response\n     */\n    utils.featureCollection = function(records, callback) {\n        return geojsonNormalize({ type: 'FeatureCollection', features: records });\n    };\n\n    /**\n     * Converts a single GeoJSON feature into backend format\n     * @param {object} feature - a GeoJSON feature\n     * @param {string} dataset - the name of the dataset the feature belongs to\n     * @returns {object[]} an array: The first element is a DynamoDB record suitable for inserting via dyno.putItem, the second are parameters suitable for uploading via s3.putObject.\n     */\n    utils.toDatabaseRecord = function(feature, dataset) {\n        var f = feature.hasOwnProperty('id') ? _.clone(feature) : _.extend({ id: cuid() }, feature);\n        var primary = f.id;\n\n        if (!f.geometry || !f.geometry.coordinates)\n            throw new Error('Unlocated features can not be stored.');\n\n        var info = Metadata(config.dyno, dataset).getFeatureInfo(f);\n        var buf = geobuf.featureToGeobuf(f).toBuffer();\n        var tile = tilebelt.bboxToTile([info.west, info.south, info.east, info.north]);\n        var cell = tilebelt.tileToQuadkey(tile);\n        var useS3 = buf.length >= config.MAX_GEOMETRY_SIZE;\n        var s3Key = [config.prefix, dataset, primary, +new Date()].join('/');\n        var s3Params = { Bucket: config.bucket, Key: s3Key, Body: buf };\n\n        var item = {\n            dataset: dataset,\n            id: 'id!' + primary,\n            cell: 'cell!' + cell,\n            size: info.size,\n            west: truncateNum(info.west),\n            south: truncateNum(info.south),\n            east: truncateNum(info.east),\n            north: truncateNum(info.north),\n            s3url: ['s3:/', config.bucket, s3Key].join('/')\n        };\n\n        if (!useS3) item.val = buf;\n        return [item, s3Params];\n    };\n\n    return utils;\n}"
          },
          "params": [
            {
              "title": "param",
              "description": "a GeoJSON feature",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "feature"
            },
            {
              "title": "param",
              "description": "the name of the dataset the feature belongs to",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dataset"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "an array: The first element is a DynamoDB record suitable for inserting via dyno.putItem, the second are parameters suitable for uploading via s3.putObject.",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "object"
                  }
                ]
              }
            }
          ],
          "name": "toDatabaseRecord",
          "kind": "function",
          "memberof": "utils",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "utils",
            "toDatabaseRecord"
          ]
        }
      ]
    },
    "path": [
      "utils"
    ]
  }
]